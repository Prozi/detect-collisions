/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./demo/index.js":
/*!***********************!*\
  !*** ./demo/index.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("if (window.location.search.indexOf(\"?stress\") !== -1) {\n    const { Stress } = __webpack_require__(/*! ../source/examples/stress */ \"./source/examples/stress.js\");\n\n    document.body.appendChild(new Stress().element);\n} else {\n    const { Tank } = __webpack_require__(/*! ../source/examples/tank */ \"./source/examples/tank.js\");\n\n    document.body.appendChild(new Tank().element);\n}\n\n//# sourceURL=webpack://detect-collisions/./demo/index.js?");

/***/ }),

/***/ "./source/examples/stress.js":
/*!***********************************!*\
  !*** ./source/examples/stress.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Stress\": () => (/* binding */ Stress)\n/* harmony export */ });\nconst { Collisions } = __webpack_require__(/*! ../../source */ \"./source/index.js\");\n\nconst result = Collisions.createResult();\nconst width = document.body.offsetWidth;\nconst height = document.body.offsetHeight;\nconst count = 500;\nconst speed = 1;\nconst size = 5;\n\nlet frame = 0;\nlet fps_total = 0;\n\nclass Stress {\n  constructor() {\n    this.element = document.createElement(\"div\");\n    this.canvas = document.createElement(\"canvas\");\n    this.context = this.canvas.getContext(\"2d\");\n    this.collisions = new Collisions();\n    this.bodies = [];\n    this.polygons = 0;\n    this.circles = 0;\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.context.font = \"24px Arial\";\n\n    // World bounds\n    this.collisions.createPolygon(0, 0, [\n      [0, 0],\n      [width, 0],\n    ]);\n    this.collisions.createPolygon(0, 0, [\n      [width, 0],\n      [width, height],\n    ]);\n    this.collisions.createPolygon(0, 0, [\n      [width, height],\n      [0, height],\n    ]);\n    this.collisions.createPolygon(0, 0, [\n      [0, height],\n      [0, 0],\n    ]);\n\n    for (let i = 0; i < count; ++i) {\n      this.createShape(!random(0, 49));\n    }\n\n    this.element.innerHTML = `\n      <div><b>Total:</b> ${count}</div>\n      <div><b>Polygons:</b> ${this.polygons}</div>\n      <div><b>Circles:</b> ${this.circles}</div>\n      <div><label><input id=\"bvh\" type=\"checkbox\"> Show Bounding Volume Hierarchy</label></div>\n    `;\n\n    this.bvh_checkbox = this.element.querySelector(\"#bvh\");\n\n    if (this.canvas instanceof Node) {\n      this.element.appendChild(this.canvas);\n    }\n\n    const self = this;\n\n    let time = performance.now();\n\n    this.frame = requestAnimationFrame(function frame() {\n      const current_time = performance.now();\n\n      try {\n        self.update(1000 / (current_time - time));\n      } catch (err) {\n        console.warn(err.message || err);\n      }\n\n      self.frame = requestAnimationFrame(frame);\n\n      time = current_time;\n    });\n  }\n\n  update(fps) {\n    this.collisions.update();\n\n    ++frame;\n    fps_total += fps;\n\n    const average_fps = Math.round(fps_total / frame);\n\n    if (frame > 100) {\n      frame = 1;\n      fps_total = average_fps;\n    }\n\n    for (let i = 0; i < this.bodies.length; ++i) {\n      const body = this.bodies[i];\n\n      body.x += body.direction_x * speed;\n      body.y += body.direction_y * speed;\n\n      const potentials = body.potentials();\n\n      for (const body2 of potentials) {\n        if (body.collides(body2, result)) {\n          body.x -= result.overlap * result.overlap_x;\n          body.y -= result.overlap * result.overlap_y;\n\n          let dot =\n            body.direction_x * result.overlap_y +\n            body.direction_y * -result.overlap_x;\n\n          body.direction_x = 2 * dot * result.overlap_y - body.direction_x;\n          body.direction_y = 2 * dot * -result.overlap_x - body.direction_y;\n\n          dot =\n            body2.direction_x * result.overlap_y +\n            body2.direction_y * -result.overlap_x;\n\n          body2.direction_x = 2 * dot * result.overlap_y - body2.direction_x;\n          body2.direction_y = 2 * dot * -result.overlap_x - body2.direction_y;\n        }\n      }\n    }\n\n    // Clear the canvas\n    this.context.fillStyle = \"#000000\";\n    this.context.fillRect(0, 0, width, height);\n\n    // Render the bodies\n    this.context.strokeStyle = \"#FFFFFF\";\n    this.context.beginPath();\n    this.collisions.draw(this.context);\n    this.context.stroke();\n\n    // Render the BVH\n    if (this.bvh_checkbox.checked) {\n      this.context.strokeStyle = \"#00FF00\";\n      this.context.beginPath();\n      this.collisions.drawBVH(this.context);\n      this.context.stroke();\n    }\n\n    // Render the FPS\n    this.context.fillStyle = \"#FFCC00\";\n    this.context.fillText(average_fps, 10, 30);\n  }\n\n  createShape(large) {\n    const min_size = size * 0.75 * (large ? 3 : 1);\n    const max_size = size * 1.25 * (large ? 5 : 1);\n    const x = random(0, width);\n    const y = random(0, height);\n    const direction = (random(0, 360) * Math.PI) / 180;\n\n    let body;\n\n    if (random(0, 2)) {\n      body = this.collisions.createCircle(x, y, random(min_size, max_size));\n\n      ++this.circles;\n    } else {\n      body = this.collisions.createPolygon(\n        x,\n        y,\n        [\n          [-random(min_size, max_size), -random(min_size, max_size)],\n          [random(min_size, max_size), -random(min_size, max_size)],\n          [random(min_size, max_size), random(min_size, max_size)],\n          [-random(min_size, max_size), random(3, size)],\n        ],\n        (random(0, 360) * Math.PI) / 180\n      );\n\n      ++this.polygons;\n    }\n\n    body.direction_x = Math.cos(direction);\n    body.direction_y = Math.sin(direction);\n\n    this.bodies.push(body);\n  }\n}\n\nfunction random(min, max) {\n  return Math.floor(Math.random() * max) + min;\n}\n\n\n//# sourceURL=webpack://detect-collisions/./source/examples/stress.js?");

/***/ }),

/***/ "./source/examples/tank.js":
/*!*********************************!*\
  !*** ./source/examples/tank.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Tank\": () => (/* binding */ Tank)\n/* harmony export */ });\nconst { Collisions } = __webpack_require__(/*! ../../source */ \"./source/index.js\");\n\nconst result = Collisions.createResult();\n\nclass Tank {\n  constructor() {\n    const width = document.body.offsetWidth;\n    const height = document.body.offsetHeight;\n    const collisions = new Collisions();\n\n    this.element = document.createElement(\"div\");\n    this.canvas = document.createElement(\"canvas\");\n    this.context = this.canvas.getContext(\"2d\");\n    this.collisions = collisions;\n    this.bodies = [];\n\n    this.canvas.width = width;\n    this.canvas.height = height;\n    this.player = null;\n\n    this.up = false;\n    this.down = false;\n    this.left = false;\n    this.right = false;\n\n    this.element.innerHTML = `\n      <div><b>W, S</b> - Accelerate/Decelerate</div>\n      <div><b>A, D</b> - Turn</div>\n      <div><label><input id=\"bvh\" type=\"checkbox\"> Show Bounding Volume Hierarchy</label></div>\n    `;\n\n    const updateKeys = (e) => {\n      const keydown = e.type === \"keydown\";\n      const key = e.key.toLowerCase();\n\n      key === \"w\" && (this.up = keydown);\n      key === \"s\" && (this.down = keydown);\n      key === \"a\" && (this.left = keydown);\n      key === \"d\" && (this.right = keydown);\n    };\n\n    document.addEventListener(\"keydown\", updateKeys);\n    document.addEventListener(\"keyup\", updateKeys);\n\n    this.bvh_checkbox = this.element.querySelector(\"#bvh\");\n\n    if (this.canvas instanceof Node) {\n      this.element.appendChild(this.canvas);\n    }\n\n    this.createPlayer(width / 2, height / 2);\n    this.createMap(width, height);\n\n    const frame = () => {\n      try {\n        this.update();\n      } catch (err) {\n        console.warn(err.message || err);\n      }\n      requestAnimationFrame(frame);\n    };\n\n    frame();\n  }\n\n  update() {\n    this.handleInput();\n    this.processGameLogic();\n    this.handleCollisions();\n    this.render();\n  }\n\n  handleInput() {\n    this.up && (this.player.velocity += 0.1);\n    this.down && (this.player.velocity -= 0.1);\n    this.left && (this.player.angle -= 0.04);\n    this.right && (this.player.angle += 0.04);\n  }\n\n  processGameLogic() {\n    const x = Math.cos(this.player.angle);\n    const y = Math.sin(this.player.angle);\n\n    if (this.player.velocity > 0) {\n      this.player.velocity -= 0.05;\n\n      if (this.player.velocity > 3) {\n        this.player.velocity = 3;\n      }\n    } else if (this.player.velocity < 0) {\n      this.player.velocity += 0.05;\n\n      if (this.player.velocity < -2) {\n        this.player.velocity = -2;\n      }\n    }\n\n    if (!Math.round(this.player.velocity * 100)) {\n      this.player.velocity = 0;\n    }\n\n    if (this.player.velocity) {\n      this.player.x += x * this.player.velocity;\n      this.player.y += y * this.player.velocity;\n    }\n  }\n\n  handleCollisions() {\n    this.collisions.update();\n\n    const potentials = this.player.potentials();\n\n    // Negate any collisions\n    for (const body of potentials) {\n      if (this.player.collides(body, result)) {\n        this.player.x -= result.overlap * result.overlap_x;\n        this.player.y -= result.overlap * result.overlap_y;\n\n        this.player.velocity *= 0.9;\n      }\n    }\n  }\n\n  render() {\n    this.context.fillStyle = \"#000000\";\n    this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.context.strokeStyle = \"#FFFFFF\";\n    this.context.beginPath();\n    this.collisions.draw(this.context);\n    this.context.stroke();\n\n    if (this.bvh_checkbox.checked) {\n      this.context.strokeStyle = \"#00FF00\";\n      this.context.beginPath();\n      this.collisions.drawBVH(this.context);\n      this.context.stroke();\n    }\n  }\n\n  createPlayer(x, y, size = 15) {\n    this.player = this.collisions.createPolygon(\n      x,\n      y,\n      [\n        [-size * 2, -size],\n        [size * 2, -size],\n        [size * 2, size],\n        [-size * 2, size],\n      ],\n      0.2\n    );\n\n    this.player.velocity = 0;\n  }\n\n  scaleX(x) {\n    return (x / 800) * this.canvas.width;\n  }\n\n  scaleY(y) {\n    return (y / 600) * this.canvas.height;\n  }\n\n  createCircle(x, y, radius) {\n    this.collisions.createCircle(this.scaleX(x), this.scaleY(y), radius);\n  }\n\n  createPolygon(x, y, points, angle) {\n    const scaledPoints = points.map(([pointX, pointY]) => [\n      this.scaleX(pointX),\n      this.scaleY(pointY),\n    ]);\n\n    this.collisions.createPolygon(\n      this.scaleX(x),\n      this.scaleY(y),\n      scaledPoints,\n      angle\n    );\n  }\n\n  createMap(width, height) {\n    // World bounds\n    this.createPolygon(0, 0, [\n      [0, 0],\n      [width, 0],\n    ]);\n    this.createPolygon(0, 0, [\n      [width, 0],\n      [width, height],\n    ]);\n    this.createPolygon(0, 0, [\n      [width, height],\n      [0, height],\n    ]);\n    this.createPolygon(0, 0, [\n      [0, height],\n      [0, 0],\n    ]);\n\n    // Factory\n    this.createPolygon(\n      100,\n      100,\n      [\n        [-50, -50],\n        [50, -50],\n        [50, 50],\n        [-50, 50],\n      ],\n      0.4\n    );\n    this.createPolygon(\n      190,\n      105,\n      [\n        [-20, -20],\n        [20, -20],\n        [20, 20],\n        [-20, 20],\n      ],\n      0.4\n    );\n    this.createCircle(170, 140, 8);\n    this.createCircle(185, 155, 8);\n    this.createCircle(165, 165, 8);\n    this.createCircle(145, 165, 8);\n\n    // Airstrip\n    this.createPolygon(\n      230,\n      50,\n      [\n        [-150, -30],\n        [150, -30],\n        [150, 30],\n        [-150, 30],\n      ],\n      0.4\n    );\n\n    // HQ\n    this.createPolygon(\n      100,\n      500,\n      [\n        [-40, -50],\n        [40, -50],\n        [50, 50],\n        [-50, 50],\n      ],\n      0.2\n    );\n    this.createCircle(180, 490, 20);\n    this.createCircle(175, 540, 20);\n\n    // Barracks\n    this.createPolygon(\n      400,\n      500,\n      [\n        [-60, -20],\n        [60, -20],\n        [60, 20],\n        [-60, 20],\n      ],\n      1.7\n    );\n    this.createPolygon(\n      350,\n      494,\n      [\n        [-60, -20],\n        [60, -20],\n        [60, 20],\n        [-60, 20],\n      ],\n      1.7\n    );\n\n    // Mountains\n    this.createPolygon(750, 0, [\n      [0, 0],\n      [-20, 100],\n    ]);\n    this.createPolygon(750, 0, [\n      [-20, 100],\n      [30, 250],\n    ]);\n    this.createPolygon(750, 0, [\n      [30, 250],\n      [20, 300],\n    ]);\n    this.createPolygon(750, 0, [\n      [20, 300],\n      [-50, 320],\n    ]);\n    this.createPolygon(750, 0, [\n      [-50, 320],\n      [-90, 500],\n    ]);\n    this.createPolygon(750, 0, [\n      [-90, 500],\n      [-200, 600],\n    ]);\n\n    // Lake\n    this.createPolygon(550, 100, [\n      [-60, -20],\n      [-20, -40],\n      [30, -30],\n      [60, 20],\n      [40, 70],\n      [10, 100],\n      [-30, 110],\n      [-80, 90],\n      [-110, 50],\n      [-100, 20],\n    ]);\n  }\n}\n\n\n//# sourceURL=webpack://detect-collisions/./source/examples/tank.js?");

/***/ }),

/***/ "./source/index.js":
/*!*************************!*\
  !*** ./source/index.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { BVH, Circle, Polygon, Point, Result, SAT } = __webpack_require__(/*! ./modules */ \"./source/modules/index.js\");\n\n/**\n * A collision system used to track bodies in order to improve collision detection performance\n * @class\n */\nclass Collisions {\n  /**\n   * @constructor\n   */\n  constructor() {\n    /** @private */\n    this._bvh = new BVH();\n  }\n\n  /**\n   * Creates a {@link Circle} and inserts it into the collision system\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [radius = 0] The radius\n   * @param {Number} [scale = 1] The scale\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   * @returns {Circle}\n   */\n  createCircle(x = 0, y = 0, radius = 0, scale = 1, padding = 0) {\n    const body = new Circle(x, y, radius, scale, padding);\n\n    this._bvh.insert(body);\n\n    return body;\n  }\n\n  /**\n   * Creates a {@link Polygon} and inserts it into the collision system\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n   * @param {Number} [angle = 0] The starting rotation in radians\n   * @param {Number} [scale_x = 1] The starting scale along the X axis\n   * @param {Number} [scale_y = 1] The starting scale long the Y axis\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   * @returns {Polygon}\n   */\n  createPolygon(\n    x = 0,\n    y = 0,\n    points = [[0, 0]],\n    angle = 0,\n    scale_x = 1,\n    scale_y = 1,\n    padding = 0\n  ) {\n    const body = new Polygon(x, y, points, angle, scale_x, scale_y, padding);\n\n    this._bvh.insert(body);\n\n    return body;\n  }\n\n  /**\n   * Creates a {@link Point} and inserts it into the collision system\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   * @returns {Point}\n   */\n  createPoint(x = 0, y = 0, padding = 0) {\n    const body = new Point(x, y, padding);\n\n    this._bvh.insert(body);\n\n    return body;\n  }\n\n  /**\n   * Creates a {@link Result} used to collect the detailed results of a collision test\n   */\n  createResult() {\n    return new Result();\n  }\n\n  /**\n   * Creates a Result used to collect the detailed results of a collision test\n   */\n  static createResult() {\n    return new Result();\n  }\n\n  /**\n   * Inserts bodies into the collision system\n   * @param {...Circle|...Polygon|...Point} bodies\n   */\n  insert(...bodies) {\n    for (const body of bodies) {\n      this._bvh.insert(body, false);\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes bodies = require(the collision system\n   * @param {...Circle|...Polygon|...Point} bodies\n   */\n  remove(...bodies) {\n    for (const body of bodies) {\n      this._bvh.remove(body, false);\n    }\n\n    return this;\n  }\n\n  /**\n   * Updates the collision system. This should be called before any collisions are tested.\n   */\n  update() {\n    this._bvh.update();\n\n    return this;\n  }\n\n  /**\n   * Draws the bodies within the system to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  draw(context) {\n    return this._bvh.draw(context);\n  }\n\n  /**\n   * Draws the system's BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  drawBVH(context) {\n    return this._bvh.drawBVH(context);\n  }\n\n  /**\n   * Returns a list of potential collisions for a body\n   * @param {Circle|Polygon|Point} body The body to test for potential collisions against\n   * @returns {Array<Body>}\n   */\n  potentials(body) {\n    return this._bvh.potentials(body);\n  }\n\n  /**\n   * Determines if two bodies are colliding\n   * @param {Circle|Polygon|Point} source Source body to test against\n   * @param {Circle|Polygon|Point} target The target body to test against\n   * @param {Result} [result = null] A Result object on which to store information about the collision\n   * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n   * @returns {Boolean}\n   */\n  collides(source, target, result = null, aabb = true) {\n    return SAT(source, target, result, aabb);\n  }\n}\n\nmodule.exports = {\n  Collisions,\n  BVH,\n  Circle,\n  Polygon,\n  Point,\n  Result,\n  SAT,\n};\n\n\n//# sourceURL=webpack://detect-collisions/./source/index.js?");

/***/ }),

/***/ "./source/modules/BVH.js":
/*!*******************************!*\
  !*** ./source/modules/BVH.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const BVHBranch = __webpack_require__(/*! ./BVHBranch */ \"./source/modules/BVHBranch.js\");\n\n/**\n * A Bounding Volume Hierarchy (BVH) used to find potential collisions quickly\n * @class\n * @private\n */\nclass BVH {\n  /**\n   * @constructor\n   */\n  constructor() {\n    /** @private */\n    this._hierarchy = null;\n\n    /** @private */\n    this._bodies = [];\n\n    /** @private */\n    this._dirty_branches = [];\n  }\n\n  /**\n   * Inserts a body into the BVH\n   * @param {Circle|Polygon|Point} body The body to insert\n   * @param {Boolean} [updating = false] Set to true if the body already exists in the BVH (used internally when updating the body's position)\n   */\n  insert(body, updating = false) {\n    if (!updating) {\n      const bvh = body._bvh;\n\n      if (bvh && bvh !== this) {\n        throw new Error(\"Body belongs to another collision system\");\n      }\n\n      body._bvh = this;\n      this._bodies.push(body);\n    }\n\n    const polygon = body._polygon;\n    const body_x = body.x;\n    const body_y = body.y;\n\n    if (polygon) {\n      if (\n        body._dirty_coords ||\n        body.x !== body._x ||\n        body.y !== body._y ||\n        body.angle !== body._angle ||\n        body.scale_x !== body._scale_x ||\n        body.scale_y !== body._scale_y\n      ) {\n        body._calculateCoords();\n      }\n    }\n\n    const padding = body._bvh_padding;\n    const radius = polygon ? 0 : body.radius * body.scale;\n    const body_min_x = (polygon ? body._min_x : body_x - radius) - padding;\n    const body_min_y = (polygon ? body._min_y : body_y - radius) - padding;\n    const body_max_x = (polygon ? body._max_x : body_x + radius) + padding;\n    const body_max_y = (polygon ? body._max_y : body_y + radius) + padding;\n\n    body._bvh_min_x = body_min_x;\n    body._bvh_min_y = body_min_y;\n    body._bvh_max_x = body_max_x;\n    body._bvh_max_y = body_max_y;\n\n    let current = this._hierarchy;\n    let sort = 0;\n\n    if (!current) {\n      this._hierarchy = body;\n    } else {\n      while (true) {\n        // Branch\n        if (current._bvh_branch) {\n          const left = current._bvh_left;\n          const left_min_y = left._bvh_min_y;\n          const left_max_x = left._bvh_max_x;\n          const left_max_y = left._bvh_max_y;\n          const left_new_min_x =\n            body_min_x < left._bvh_min_x ? body_min_x : left._bvh_min_x;\n          const left_new_min_y =\n            body_min_y < left_min_y ? body_min_y : left_min_y;\n          const left_new_max_x =\n            body_max_x > left_max_x ? body_max_x : left_max_x;\n          const left_new_max_y =\n            body_max_y > left_max_y ? body_max_y : left_max_y;\n          const left_volume =\n            (left_max_x - left._bvh_min_x) * (left_max_y - left_min_y);\n          const left_new_volume =\n            (left_new_max_x - left_new_min_x) *\n            (left_new_max_y - left_new_min_y);\n          const left_difference = left_new_volume - left_volume;\n\n          const right = current._bvh_right;\n          const right_min_x = right._bvh_min_x;\n          const right_min_y = right._bvh_min_y;\n          const right_max_x = right._bvh_max_x;\n          const right_max_y = right._bvh_max_y;\n          const right_new_min_x =\n            body_min_x < right_min_x ? body_min_x : right_min_x;\n          const right_new_min_y =\n            body_min_y < right_min_y ? body_min_y : right_min_y;\n          const right_new_max_x =\n            body_max_x > right_max_x ? body_max_x : right_max_x;\n          const right_new_max_y =\n            body_max_y > right_max_y ? body_max_y : right_max_y;\n          const right_volume =\n            (right_max_x - right_min_x) * (right_max_y - right_min_y);\n          const right_new_volume =\n            (right_new_max_x - right_new_min_x) *\n            (right_new_max_y - right_new_min_y);\n          const right_difference = right_new_volume - right_volume;\n\n          current._bvh_sort = sort++;\n          current._bvh_min_x =\n            left_new_min_x < right_new_min_x ? left_new_min_x : right_new_min_x;\n          current._bvh_min_y =\n            left_new_min_y < right_new_min_y ? left_new_min_y : right_new_min_y;\n          current._bvh_max_x =\n            left_new_max_x > right_new_max_x ? left_new_max_x : right_new_max_x;\n          current._bvh_max_y =\n            left_new_max_y > right_new_max_y ? left_new_max_y : right_new_max_y;\n\n          current = left_difference <= right_difference ? left : right;\n        } else {\n          // Leaf\n          const grandparent = current._bvh_parent;\n          const parent_min_x = current._bvh_min_x;\n          const parent_min_y = current._bvh_min_y;\n          const parent_max_x = current._bvh_max_x;\n          const parent_max_y = current._bvh_max_y;\n          const new_parent =\n            (current._bvh_parent =\n            body._bvh_parent =\n              BVHBranch.getBranch());\n\n          new_parent._bvh_parent = grandparent;\n          new_parent._bvh_left = current;\n          new_parent._bvh_right = body;\n          new_parent._bvh_sort = sort++;\n          new_parent._bvh_min_x =\n            body_min_x < parent_min_x ? body_min_x : parent_min_x;\n          new_parent._bvh_min_y =\n            body_min_y < parent_min_y ? body_min_y : parent_min_y;\n          new_parent._bvh_max_x =\n            body_max_x > parent_max_x ? body_max_x : parent_max_x;\n          new_parent._bvh_max_y =\n            body_max_y > parent_max_y ? body_max_y : parent_max_y;\n\n          if (!grandparent) {\n            this._hierarchy = new_parent;\n          } else if (grandparent._bvh_left === current) {\n            grandparent._bvh_left = new_parent;\n          } else {\n            grandparent._bvh_right = new_parent;\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Removes a body from the BVH\n   * @param {Circle|Polygon|Point} body The body to remove\n   * @param {Boolean} [updating = false] Set to true if this is a temporary removal (used internally when updating the body's position)\n   */\n  remove(body, updating = false) {\n    if (!updating) {\n      const bvh = body._bvh;\n\n      if (bvh && bvh !== this) {\n        throw new Error(\"Body belongs to another collision system\");\n      }\n\n      body._bvh = null;\n      this._bodies.splice(this._bodies.indexOf(body), 1);\n    }\n\n    if (this._hierarchy === body) {\n      this._hierarchy = null;\n\n      return;\n    }\n\n    const parent = body._bvh_parent;\n    const grandparent = parent._bvh_parent;\n    const parent_left = parent._bvh_left;\n    const sibling = parent_left === body ? parent._bvh_right : parent_left;\n\n    sibling._bvh_parent = grandparent;\n\n    if (sibling._bvh_branch) {\n      sibling._bvh_sort = parent._bvh_sort;\n    }\n\n    if (grandparent) {\n      if (grandparent._bvh_left === parent) {\n        grandparent._bvh_left = sibling;\n      } else {\n        grandparent._bvh_right = sibling;\n      }\n\n      let branch = grandparent;\n\n      while (branch) {\n        const left = branch._bvh_left;\n        const left_min_x = left._bvh_min_x;\n        const left_min_y = left._bvh_min_y;\n        const left_max_x = left._bvh_max_x;\n        const left_max_y = left._bvh_max_y;\n\n        const right = branch._bvh_right;\n        const right_min_x = right._bvh_min_x;\n        const right_min_y = right._bvh_min_y;\n        const right_max_x = right._bvh_max_x;\n        const right_max_y = right._bvh_max_y;\n\n        branch._bvh_min_x = left_min_x < right_min_x ? left_min_x : right_min_x;\n        branch._bvh_min_y = left_min_y < right_min_y ? left_min_y : right_min_y;\n        branch._bvh_max_x = left_max_x > right_max_x ? left_max_x : right_max_x;\n        branch._bvh_max_y = left_max_y > right_max_y ? left_max_y : right_max_y;\n\n        branch = branch._bvh_parent;\n      }\n    } else {\n      this._hierarchy = sibling;\n    }\n\n    BVHBranch.releaseBranch(parent);\n  }\n\n  /**\n   * Updates the BVH. Moved bodies are removed/inserted.\n   */\n  update() {\n    const bodies = this._bodies;\n    const count = bodies.length;\n\n    for (let i = 0; i < count; ++i) {\n      const body = bodies[i];\n\n      let update = false;\n\n      if (!update && body.padding !== body._bvh_padding) {\n        body._bvh_padding = body.padding;\n        update = true;\n      }\n\n      if (!update) {\n        const polygon = body._polygon;\n\n        if (polygon) {\n          if (\n            body._dirty_coords ||\n            body.x !== body._x ||\n            body.y !== body._y ||\n            body.angle !== body._angle ||\n            body.scale_x !== body._scale_x ||\n            body.scale_y !== body._scale_y\n          ) {\n            body._calculateCoords();\n          }\n        }\n\n        const x = body.x;\n        const y = body.y;\n        const radius = polygon ? 0 : body.radius * body.scale;\n        const min_x = polygon ? body._min_x : x - radius;\n        const min_y = polygon ? body._min_y : y - radius;\n        const max_x = polygon ? body._max_x : x + radius;\n        const max_y = polygon ? body._max_y : y + radius;\n\n        update =\n          min_x < body._bvh_min_x ||\n          min_y < body._bvh_min_y ||\n          max_x > body._bvh_max_x ||\n          max_y > body._bvh_max_y;\n      }\n\n      if (update) {\n        this.remove(body, true);\n        this.insert(body, true);\n      }\n    }\n  }\n\n  /**\n   * Returns a list of potential collisions for a body\n   * @param {Circle|Polygon|Point} body The body to test\n   * @returns {Array<Body>}\n   */\n  potentials(body) {\n    const results = [];\n    const min_x = body._bvh_min_x;\n    const min_y = body._bvh_min_y;\n    const max_x = body._bvh_max_x;\n    const max_y = body._bvh_max_y;\n\n    let current = this._hierarchy;\n    let traverse_left = true;\n\n    if (!current || !current._bvh_branch) {\n      return results;\n    }\n\n    while (current) {\n      if (traverse_left) {\n        traverse_left = false;\n\n        let left = current._bvh_branch ? current._bvh_left : null;\n\n        while (\n          left &&\n          left._bvh_max_x >= min_x &&\n          left._bvh_max_y >= min_y &&\n          left._bvh_min_x <= max_x &&\n          left._bvh_min_y <= max_y\n        ) {\n          current = left;\n          left = current._bvh_branch ? current._bvh_left : null;\n        }\n      }\n\n      const branch = current._bvh_branch;\n      const right = branch ? current._bvh_right : null;\n\n      if (\n        right &&\n        right._bvh_max_x > min_x &&\n        right._bvh_max_y > min_y &&\n        right._bvh_min_x < max_x &&\n        right._bvh_min_y < max_y\n      ) {\n        current = right;\n        traverse_left = true;\n      } else {\n        if (!branch && current !== body) {\n          results.push(current);\n        }\n\n        let parent = current._bvh_parent;\n\n        if (parent) {\n          while (parent && parent._bvh_right === current) {\n            current = parent;\n            parent = current._bvh_parent;\n          }\n\n          current = parent;\n        } else {\n          break;\n        }\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Draws the bodies within the BVH to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  draw(context) {\n    const bodies = this._bodies;\n    const count = bodies.length;\n\n    for (let i = 0; i < count; ++i) {\n      bodies[i].draw(context);\n    }\n  }\n\n  /**\n   * Draws the BVH to a CanvasRenderingContext2D's current path. This is useful for testing out different padding values for bodies.\n   * @param {CanvasRenderingContext2D} context The context to draw to\n   */\n  drawBVH(context) {\n    let current = this._hierarchy;\n    let traverse_left = true;\n\n    while (current) {\n      if (traverse_left) {\n        traverse_left = false;\n\n        let left = current._bvh_branch ? current._bvh_left : null;\n\n        while (left) {\n          current = left;\n          left = current._bvh_branch ? current._bvh_left : null;\n        }\n      }\n\n      const branch = current._bvh_branch;\n      const min_x = current._bvh_min_x;\n      const min_y = current._bvh_min_y;\n      const max_x = current._bvh_max_x;\n      const max_y = current._bvh_max_y;\n      const right = branch ? current._bvh_right : null;\n\n      context.moveTo(min_x, min_y);\n      context.lineTo(max_x, min_y);\n      context.lineTo(max_x, max_y);\n      context.lineTo(min_x, max_y);\n      context.lineTo(min_x, min_y);\n\n      if (right) {\n        current = right;\n        traverse_left = true;\n      } else {\n        let parent = current._bvh_parent;\n\n        if (parent) {\n          while (parent && parent._bvh_right === current) {\n            current = parent;\n            parent = current._bvh_parent;\n          }\n\n          current = parent;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n}\n\nmodule.exports = BVH;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/BVH.js?");

/***/ }),

/***/ "./source/modules/BVHBranch.js":
/*!*************************************!*\
  !*** ./source/modules/BVHBranch.js ***!
  \*************************************/
/***/ ((module) => {

eval("/**\n * @private\n */\nconst branch_pool = [];\n\n/**\n * A branch within a BVH\n * @class\n * @private\n */\nclass BVHBranch {\n  /**\n   * @constructor\n   */\n  constructor() {\n    /** @private */\n    this._bvh_parent = null;\n\n    /** @private */\n    this._bvh_branch = true;\n\n    /** @private */\n    this._bvh_left = null;\n\n    /** @private */\n    this._bvh_right = null;\n\n    /** @private */\n    this._bvh_sort = 0;\n\n    /** @private */\n    this._bvh_min_x = 0;\n\n    /** @private */\n    this._bvh_min_y = 0;\n\n    /** @private */\n    this._bvh_max_x = 0;\n\n    /** @private */\n    this._bvh_max_y = 0;\n  }\n\n  /**\n   * Returns a branch from the branch pool or creates a new branch\n   * @returns {BVHBranch}\n   */\n  static getBranch() {\n    if (branch_pool.length) {\n      return branch_pool.pop();\n    }\n\n    return new BVHBranch();\n  }\n\n  /**\n   * Releases a branch back into the branch pool\n   * @param {BVHBranch} branch The branch to release\n   */\n  static releaseBranch(branch) {\n    branch_pool.push(branch);\n  }\n\n  /**\n   * Sorting callback used to sort branches by deepest first\n   * @param {BVHBranch} a The first branch\n   * @param {BVHBranch} b The second branch\n   * @returns {Number}\n   */\n  static sortBranches(a, b) {\n    return a.sort > b.sort ? -1 : 1;\n  }\n}\n\nmodule.exports = BVHBranch;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/BVHBranch.js?");

/***/ }),

/***/ "./source/modules/Body.js":
/*!********************************!*\
  !*** ./source/modules/Body.js ***!
  \********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Result = __webpack_require__(/*! ./Result */ \"./source/modules/Result.js\");\nconst SAT = __webpack_require__(/*! ./SAT */ \"./source/modules/SAT.js\");\n\n/**\n * The base class for bodies used to detect collisions\n * @class\n * @protected\n */\nclass Body {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor(x = 0, y = 0, padding = 0) {\n    /**\n     * @desc The X coordinate of the body\n     * @type {Number}\n     */\n    this.x = x;\n\n    /**\n     * @desc The Y coordinate of the body\n     * @type {Number}\n     */\n    this.y = y;\n\n    /**\n     * @desc The amount to pad the bounding volume when testing for potential collisions\n     * @type {Number}\n     */\n    this.padding = padding;\n\n    /** @private */\n    this._circle = false;\n\n    /** @private */\n    this._polygon = false;\n\n    /** @private */\n    this._point = false;\n\n    /** @private */\n    this._bvh = null;\n\n    /** @private */\n    this._bvh_parent = null;\n\n    /** @private */\n    this._bvh_branch = false;\n\n    /** @private */\n    this._bvh_padding = padding;\n\n    /** @private */\n    this._bvh_min_x = 0;\n\n    /** @private */\n    this._bvh_min_y = 0;\n\n    /** @private */\n    this._bvh_max_x = 0;\n\n    /** @private */\n    this._bvh_max_y = 0;\n  }\n\n  /**\n   * Determines if the body is colliding with another body\n   * @param {Circle|Polygon|Point} target The target body to test against\n   * @param {Result} [result = null] A Result object on which to store information about the collision\n   * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own potential collision heuristic)\n   * @returns {Boolean}\n   */\n  collides(target, result = null, aabb = true) {\n    return SAT(this, target, result, aabb);\n  }\n\n  /**\n   * Returns a list of potential collisions\n   * @returns {Array<Body>}\n   */\n  potentials() {\n    const bvh = this._bvh;\n\n    if (bvh === null) {\n      throw new Error(\"Body does not belong to a collision system\");\n    }\n\n    return bvh.potentials(this);\n  }\n\n  /**\n   * Removes the body from its current collision system\n   */\n  remove() {\n    const bvh = this._bvh;\n\n    if (bvh) {\n      bvh.remove(this, false);\n    }\n  }\n\n  /**\n   * Creates a {@link Result} used to collect the detailed results of a collision test\n   */\n  createResult() {\n    return new Result();\n  }\n\n  /**\n   * Creates a Result used to collect the detailed results of a collision test\n   */\n  static createResult() {\n    return new Result();\n  }\n}\n\nmodule.exports = Body;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/Body.js?");

/***/ }),

/***/ "./source/modules/Circle.js":
/*!**********************************!*\
  !*** ./source/modules/Circle.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Body = __webpack_require__(/*! ./Body */ \"./source/modules/Body.js\");\n\n/**\n * A circle used to detect collisions\n * @class\n */\nclass Circle extends Body {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [radius = 0] The radius\n   * @param {Number} [scale = 1] The scale\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor(x = 0, y = 0, radius = 0, scale = 1, padding = 0) {\n    super(x, y, padding);\n\n    /**\n     * @type {Number}\n     */\n    this.radius = radius;\n\n    /**\n     * @type {Number}\n     */\n    this.scale = scale;\n  }\n\n  /**\n   * Draws the circle to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to add the arc to\n   */\n  draw(context) {\n    const x = this.x;\n    const y = this.y;\n    const radius = this.radius * this.scale;\n\n    context.moveTo(x + radius, y);\n    context.arc(x, y, radius, 0, Math.PI * 2);\n  }\n}\n\nmodule.exports = Circle;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/Circle.js?");

/***/ }),

/***/ "./source/modules/Point.js":
/*!*********************************!*\
  !*** ./source/modules/Point.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Polygon = __webpack_require__(/*! ./Polygon */ \"./source/modules/Polygon.js\");\n\n/**\n * A point used to detect collisions\n * @class\n */\nclass Point extends Polygon {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor(x = 0, y = 0, padding = 0) {\n    super(x, y, [[0, 0]], 0, 1, 1, padding);\n\n    /** @private */\n    this._point = true;\n  }\n}\n\nPoint.prototype.setPoints = undefined;\n\nmodule.exports = Point;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/Point.js?");

/***/ }),

/***/ "./source/modules/Polygon.js":
/*!***********************************!*\
  !*** ./source/modules/Polygon.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Body = __webpack_require__(/*! ./Body */ \"./source/modules/Body.js\");\n\n/**\n * A polygon used to detect collisions\n * @class\n */\nclass Polygon extends Body {\n  /**\n   * @constructor\n   * @param {Number} [x = 0] The starting X coordinate\n   * @param {Number} [y = 0] The starting Y coordinate\n   * @param {Array<Number[]>} [points = []] An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n   * @param {Number} [angle = 0] The starting rotation in radians\n   * @param {Number} [scale_x = 1] The starting scale along the X axis\n   * @param {Number} [scale_y = 1] The starting scale long the Y axis\n   * @param {Number} [padding = 0] The amount to pad the bounding volume when testing for potential collisions\n   */\n  constructor(\n    x = 0,\n    y = 0,\n    points = [],\n    angle = 0,\n    scale_x = 1,\n    scale_y = 1,\n    padding = 0\n  ) {\n    super(x, y, padding);\n\n    /**\n     * @desc The angle of the body in radians\n     * @type {Number}\n     */\n    this.angle = angle;\n\n    /**\n     * @desc The scale of the body along the X axis\n     * @type {Number}\n     */\n    this.scale_x = scale_x;\n\n    /**\n     * @desc The scale of the body along the Y axis\n     * @type {Number}\n     */\n    this.scale_y = scale_y;\n\n    /** @private */\n    this._polygon = true;\n\n    /** @private */\n    this._x = x;\n\n    /** @private */\n    this._y = y;\n\n    /** @private */\n    this._angle = angle;\n\n    /** @private */\n    this._scale_x = scale_x;\n\n    /** @private */\n    this._scale_y = scale_y;\n\n    /** @private */\n    this._min_x = 0;\n\n    /** @private */\n    this._min_y = 0;\n\n    /** @private */\n    this._max_x = 0;\n\n    /** @private */\n    this._max_y = 0;\n\n    /** @private */\n    this._points = null;\n\n    /** @private */\n    this._coords = null;\n\n    /** @private */\n    this._edges = null;\n\n    /** @private */\n    this._normals = null;\n\n    /** @private */\n    this._dirty_coords = true;\n\n    /** @private */\n    this._dirty_normals = true;\n\n    Polygon.prototype.setPoints.call(this, points);\n  }\n\n  /**\n   * Draws the polygon to a CanvasRenderingContext2D's current path\n   * @param {CanvasRenderingContext2D} context The context to add the shape to\n   */\n  draw(context) {\n    if (\n      this._dirty_coords ||\n      this.x !== this._x ||\n      this.y !== this._y ||\n      this.angle !== this._angle ||\n      this.scale_x !== this._scale_x ||\n      this.scale_y !== this._scale_y\n    ) {\n      this._calculateCoords();\n    }\n\n    const coords = this._coords;\n\n    if (coords.length === 2) {\n      context.moveTo(coords[0], coords[1]);\n      context.arc(coords[0], coords[1], 1, 0, Math.PI * 2);\n    } else {\n      context.moveTo(coords[0], coords[1]);\n\n      for (let i = 2; i < coords.length; i += 2) {\n        context.lineTo(coords[i], coords[i + 1]);\n      }\n\n      if (coords.length > 4) {\n        context.lineTo(coords[0], coords[1]);\n      }\n    }\n  }\n\n  /**\n   * Sets the points making up the polygon. It's important to use this function when changing the polygon's shape to ensure internal data is also updated.\n   * @param {Array<Number[]>} new_points An array of coordinate pairs making up the polygon - [[x1, y1], [x2, y2], ...]\n   */\n  setPoints(new_points) {\n    const count = new_points.length;\n\n    this._points = new Float64Array(count * 2);\n    this._coords = new Float64Array(count * 2);\n    this._edges = new Float64Array(count * 2);\n    this._normals = new Float64Array(count * 2);\n\n    const points = this._points;\n\n    for (let i = 0, ix = 0, iy = 1; i < count; ++i, ix += 2, iy += 2) {\n      const new_point = new_points[i];\n\n      points[ix] = new_point[0];\n      points[iy] = new_point[1];\n    }\n\n    this._dirty_coords = true;\n  }\n\n  /**\n   * Calculates and caches the polygon's world coordinates based on its points, angle, and scale\n   */\n  _calculateCoords() {\n    const x = this.x;\n    const y = this.y;\n    const angle = this.angle;\n    const scale_x = this.scale_x;\n    const scale_y = this.scale_y;\n    const points = this._points;\n    const coords = this._coords;\n    const count = points.length;\n\n    let min_x;\n    let max_x;\n    let min_y;\n    let max_y;\n\n    for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n      let coord_x = points[ix] * scale_x;\n      let coord_y = points[iy] * scale_y;\n\n      if (angle) {\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        const tmp_x = coord_x;\n        const tmp_y = coord_y;\n\n        coord_x = tmp_x * cos - tmp_y * sin;\n        coord_y = tmp_x * sin + tmp_y * cos;\n      }\n\n      coord_x += x;\n      coord_y += y;\n\n      coords[ix] = coord_x;\n      coords[iy] = coord_y;\n\n      if (ix === 0) {\n        min_x = max_x = coord_x;\n        min_y = max_y = coord_y;\n      } else {\n        if (coord_x < min_x) {\n          min_x = coord_x;\n        } else if (coord_x > max_x) {\n          max_x = coord_x;\n        }\n\n        if (coord_y < min_y) {\n          min_y = coord_y;\n        } else if (coord_y > max_y) {\n          max_y = coord_y;\n        }\n      }\n    }\n\n    this._x = x;\n    this._y = y;\n    this._angle = angle;\n    this._scale_x = scale_x;\n    this._scale_y = scale_y;\n    this._min_x = min_x;\n    this._min_y = min_y;\n    this._max_x = max_x;\n    this._max_y = max_y;\n    this._dirty_coords = false;\n    this._dirty_normals = true;\n  }\n\n  /**\n   * Calculates the normals and edges of the polygon's sides\n   */\n  _calculateNormals() {\n    const coords = this._coords;\n    const edges = this._edges;\n    const normals = this._normals;\n    const count = coords.length;\n\n    for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n      const next = ix + 2 < count ? ix + 2 : 0;\n      const x = coords[next] - coords[ix];\n      const y = coords[next + 1] - coords[iy];\n      const length = x || y ? Math.sqrt(x * x + y * y) : 0;\n\n      edges[ix] = x;\n      edges[iy] = y;\n      normals[ix] = length ? y / length : 0;\n      normals[iy] = length ? -x / length : 0;\n    }\n\n    this._dirty_normals = false;\n  }\n}\n\nmodule.exports = Polygon;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/Polygon.js?");

/***/ }),

/***/ "./source/modules/Result.js":
/*!**********************************!*\
  !*** ./source/modules/Result.js ***!
  \**********************************/
/***/ ((module) => {

eval("/**\n * An object used to collect the detailed results of a collision test\n *\n * > **Note:** It is highly recommended you recycle the same Result object if possible in order to avoid wasting memory\n * @class\n */\nclass Result {\n  /**\n   * @constructor\n   */\n  constructor() {\n    /**\n     * @desc True if a collision was detected\n     * @type {Boolean}\n     */\n    this.collision = false;\n\n    /**\n     * @desc The source body tested\n     * @type {Circle|Polygon|Point}\n     */\n    this.a = null;\n\n    /**\n     * @desc The target body tested against\n     * @type {Circle|Polygon|Point}\n     */\n    this.b = null;\n\n    /**\n     * @desc True if A is completely contained within B\n     * @type {Boolean}\n     */\n    this.a_in_b = false;\n\n    /**\n     * @desc True if B is completely contained within A\n     * @type {Boolean}\n     */\n    this.b_in_a = false;\n\n    /**\n     * @desc The magnitude of the shortest axis of overlap\n     * @type {Number}\n     */\n    this.overlap = 0;\n\n    /**\n     * @desc The X direction of the shortest axis of overlap\n     * @type {Number}\n     */\n    this.overlap_x = 0;\n\n    /**\n     * @desc The Y direction of the shortest axis of overlap\n     * @type {Number}\n     */\n    this.overlap_y = 0;\n  }\n}\n\nmodule.exports = Result;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/Result.js?");

/***/ }),

/***/ "./source/modules/SAT.js":
/*!*******************************!*\
  !*** ./source/modules/SAT.js ***!
  \*******************************/
/***/ ((module) => {

eval("/**\n * Determines if two bodies are colliding using the Separating Axis Theorem\n * @private\n * @param {Circle|Polygon|Point} a The source body to test\n * @param {Circle|Polygon|Point} b The target body to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [aabb = true] Set to false to skip the AABB test (useful if you use your own collision heuristic)\n * @returns {Boolean}\n */\nfunction SAT(a, b, result = null, aabb = true) {\n  const a_polygon = a._polygon && !a.radius;\n  const b_polygon = b._polygon && !b.radius;\n\n  let collision = false;\n\n  if (result) {\n    result.a = a;\n    result.b = b;\n    result.a_in_b = true;\n    result.b_in_a = true;\n    result.overlap = null;\n    result.overlap_x = 0;\n    result.overlap_y = 0;\n  }\n\n  if (a_polygon) {\n    if (\n      a._dirty_coords ||\n      a.x !== a._x ||\n      a.y !== a._y ||\n      a.angle !== a._angle ||\n      a.scale_x !== a._scale_x ||\n      a.scale_y !== a._scale_y\n    ) {\n      a._calculateCoords();\n    }\n  }\n\n  if (b_polygon) {\n    if (\n      b._dirty_coords ||\n      b.x !== b._x ||\n      b.y !== b._y ||\n      b.angle !== b._angle ||\n      b.scale_x !== b._scale_x ||\n      b.scale_y !== b._scale_y\n    ) {\n      b._calculateCoords();\n    }\n  }\n\n  if (!aabb || aabbAABB(a, b)) {\n    if (a_polygon && a._dirty_normals) {\n      a._calculateNormals();\n    }\n\n    if (b_polygon && b._dirty_normals) {\n      b._calculateNormals();\n    }\n\n    collision =\n      a_polygon && b_polygon\n        ? polygonPolygon(a, b, result)\n        : a_polygon\n        ? polygonCircle(a, b, result, false)\n        : b_polygon\n        ? polygonCircle(b, a, result, true)\n        : circleCircle(a, b, result);\n  }\n\n  if (result) {\n    result.collision = collision;\n  }\n\n  return collision;\n}\n\n/**\n * Determines if two bodies' axis aligned bounding boxes are colliding\n * @param {Circle|Polygon|Point} a The source body to test\n * @param {Circle|Polygon|Point} b The target body to test against\n */\nfunction aabbAABB(a, b) {\n  const a_polygon = a._polygon;\n  const a_x = a_polygon ? 0 : a.x;\n  const a_y = a_polygon ? 0 : a.y;\n  const a_radius = a_polygon ? 0 : a.radius * a.scale;\n  const a_min_x = a_polygon ? a._min_x : a_x - a_radius;\n  const a_min_y = a_polygon ? a._min_y : a_y - a_radius;\n  const a_max_x = a_polygon ? a._max_x : a_x + a_radius;\n  const a_max_y = a_polygon ? a._max_y : a_y + a_radius;\n\n  const b_polygon = b._polygon;\n  const b_x = b_polygon ? 0 : b.x;\n  const b_y = b_polygon ? 0 : b.y;\n  const b_radius = b_polygon ? 0 : b.radius * b.scale;\n  const b_min_x = b_polygon ? b._min_x : b_x - b_radius;\n  const b_min_y = b_polygon ? b._min_y : b_y - b_radius;\n  const b_max_x = b_polygon ? b._max_x : b_x + b_radius;\n  const b_max_y = b_polygon ? b._max_y : b_y + b_radius;\n\n  return (\n    a_min_x < b_max_x &&\n    a_min_y < b_max_y &&\n    a_max_x > b_min_x &&\n    a_max_y > b_min_y\n  );\n}\n\n/**\n * Determines if two polygons are colliding\n * @param {Polygon} a The source polygon to test\n * @param {Polygon} b The target polygon to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction polygonPolygon(a, b, result = null) {\n  const a_count = a._coords.length;\n  const b_count = b._coords.length;\n\n  // Handle points specially\n  if (a_count === 2 && b_count === 2) {\n    const a_coords = a._coords;\n    const b_coords = b._coords;\n\n    if (result) {\n      result.overlap = 0;\n    }\n\n    return a_coords[0] === b_coords[0] && a_coords[1] === b_coords[1];\n  }\n\n  const a_coords = a._coords;\n  const b_coords = b._coords;\n  const a_normals = a._normals;\n  const b_normals = b._normals;\n\n  if (a_count > 2) {\n    for (let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n      if (\n        separatingAxis(a_coords, b_coords, a_normals[ix], a_normals[iy], result)\n      ) {\n        return false;\n      }\n    }\n  }\n\n  if (b_count > 2) {\n    for (let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n      if (\n        separatingAxis(a_coords, b_coords, b_normals[ix], b_normals[iy], result)\n      ) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines if a polygon and a circle are colliding\n * @param {Polygon} a The source polygon to test\n * @param {Circle} b The target circle to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @param {Boolean} [reverse = false] Set to true to reverse a and b in the result parameter when testing circle->polygon instead of polygon->circle\n * @returns {Boolean}\n */\nfunction polygonCircle(a, b, result = null, reverse = false) {\n  const a_coords = a._coords;\n  const a_edges = a._edges;\n  const a_normals = a._normals;\n  const b_x = b.x;\n  const b_y = b.y;\n  const b_radius = b.radius * b.scale;\n  const b_radius2 = b_radius * 2;\n  const radius_squared = b_radius * b_radius;\n  const count = a_coords.length;\n\n  let a_in_b = true;\n  let b_in_a = true;\n  let overlap = null;\n  let overlap_x = 0;\n  let overlap_y = 0;\n\n  // Handle points specially\n  if (count === 2) {\n    const coord_x = b_x - a_coords[0];\n    const coord_y = b_y - a_coords[1];\n    const length_squared = coord_x * coord_x + coord_y * coord_y;\n\n    if (length_squared > radius_squared) {\n      return false;\n    }\n\n    if (result) {\n      const length = Math.sqrt(length_squared);\n\n      overlap = b_radius - length;\n      overlap_x = coord_x / length;\n      overlap_y = coord_y / length;\n      b_in_a = false;\n    }\n  } else {\n    for (let ix = 0, iy = 1; ix < count; ix += 2, iy += 2) {\n      const coord_x = b_x - a_coords[ix];\n      const coord_y = b_y - a_coords[iy];\n      const edge_x = a_edges[ix];\n      const edge_y = a_edges[iy];\n      const dot = coord_x * edge_x + coord_y * edge_y;\n      const region =\n        dot < 0 ? -1 : dot > edge_x * edge_x + edge_y * edge_y ? 1 : 0;\n\n      let tmp_overlapping = false;\n      let tmp_overlap = 0;\n      let tmp_overlap_x = 0;\n      let tmp_overlap_y = 0;\n\n      if (\n        result &&\n        a_in_b &&\n        coord_x * coord_x + coord_y * coord_y > radius_squared\n      ) {\n        a_in_b = false;\n      }\n\n      if (region) {\n        const left = region === -1;\n        const other_x = left\n          ? ix === 0\n            ? count - 2\n            : ix - 2\n          : ix === count - 2\n          ? 0\n          : ix + 2;\n        const other_y = other_x + 1;\n        const coord2_x = b_x - a_coords[other_x];\n        const coord2_y = b_y - a_coords[other_y];\n        const edge2_x = a_edges[other_x];\n        const edge2_y = a_edges[other_y];\n        const dot2 = coord2_x * edge2_x + coord2_y * edge2_y;\n        const region2 =\n          dot2 < 0 ? -1 : dot2 > edge2_x * edge2_x + edge2_y * edge2_y ? 1 : 0;\n\n        if (region2 === -region) {\n          const target_x = left ? coord_x : coord2_x;\n          const target_y = left ? coord_y : coord2_y;\n          const length_squared = target_x * target_x + target_y * target_y;\n\n          if (length_squared > radius_squared) {\n            return false;\n          }\n\n          if (result) {\n            const length = Math.sqrt(length_squared);\n\n            tmp_overlapping = true;\n            tmp_overlap = b_radius - length;\n            tmp_overlap_x = target_x / length;\n            tmp_overlap_y = target_y / length;\n            b_in_a = false;\n          }\n        }\n      } else {\n        const normal_x = a_normals[ix];\n        const normal_y = a_normals[iy];\n        const length = coord_x * normal_x + coord_y * normal_y;\n        const absolute_length = length < 0 ? -length : length;\n\n        if (length > 0 && absolute_length > b_radius) {\n          return false;\n        }\n\n        if (result) {\n          tmp_overlapping = true;\n          tmp_overlap = b_radius - length;\n          tmp_overlap_x = normal_x;\n          tmp_overlap_y = normal_y;\n\n          if ((b_in_a && length >= 0) || tmp_overlap < b_radius2) {\n            b_in_a = false;\n          }\n        }\n      }\n\n      if (tmp_overlapping && (overlap === null || overlap > tmp_overlap)) {\n        overlap = tmp_overlap;\n        overlap_x = tmp_overlap_x;\n        overlap_y = tmp_overlap_y;\n      }\n    }\n  }\n\n  if (result) {\n    result.a_in_b = reverse ? b_in_a : a_in_b;\n    result.b_in_a = reverse ? a_in_b : b_in_a;\n    result.overlap = overlap;\n    result.overlap_x = reverse ? -overlap_x : overlap_x;\n    result.overlap_y = reverse ? -overlap_y : overlap_y;\n  }\n\n  return true;\n}\n\n/**\n * Determines if two circles are colliding\n * @param {Circle} a The source circle to test\n * @param {Circle} b The target circle to test against\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction circleCircle(a, b, result = null) {\n  const a_radius = a.radius * a.scale;\n  const b_radius = b.radius * b.scale;\n  const difference_x = b.x - a.x;\n  const difference_y = b.y - a.y;\n  const radius_sum = a_radius + b_radius;\n  const length_squared =\n    difference_x * difference_x + difference_y * difference_y;\n\n  if (length_squared > radius_sum * radius_sum) {\n    return false;\n  }\n\n  if (result) {\n    const length = Math.sqrt(length_squared);\n\n    result.a_in_b = a_radius <= b_radius && length <= b_radius - a_radius;\n    result.b_in_a = b_radius <= a_radius && length <= a_radius - b_radius;\n    result.overlap = radius_sum - length;\n    result.overlap_x = length ? difference_x / length : 1;\n    result.overlap_y = length ? difference_y / length : 1;\n  }\n\n  return true;\n}\n\n/**\n * Determines if two polygons are separated by an axis\n * @param {Array<Number[]>} a_coords The coordinates of the polygon to test\n * @param {Array<Number[]>} b_coords The coordinates of the polygon to test against\n * @param {Number} x The X direction of the axis\n * @param {Number} y The Y direction of the axis\n * @param {Result} [result = null] A Result object on which to store information about the collision\n * @returns {Boolean}\n */\nfunction separatingAxis(a_coords, b_coords, x, y, result = null) {\n  const a_count = a_coords.length;\n  const b_count = b_coords.length;\n\n  if (!a_count || !b_count) {\n    return true;\n  }\n\n  let a_start = null;\n  let a_end = null;\n  let b_start = null;\n  let b_end = null;\n\n  for (let ix = 0, iy = 1; ix < a_count; ix += 2, iy += 2) {\n    const dot = a_coords[ix] * x + a_coords[iy] * y;\n\n    if (a_start === null || a_start > dot) {\n      a_start = dot;\n    }\n\n    if (a_end === null || a_end < dot) {\n      a_end = dot;\n    }\n  }\n\n  for (let ix = 0, iy = 1; ix < b_count; ix += 2, iy += 2) {\n    const dot = b_coords[ix] * x + b_coords[iy] * y;\n\n    if (b_start === null || b_start > dot) {\n      b_start = dot;\n    }\n\n    if (b_end === null || b_end < dot) {\n      b_end = dot;\n    }\n  }\n\n  if (a_start > b_end || a_end < b_start) {\n    return true;\n  }\n\n  if (result) {\n    let overlap = 0;\n\n    if (a_start < b_start) {\n      result.a_in_b = false;\n\n      if (a_end < b_end) {\n        overlap = a_end - b_start;\n        result.b_in_a = false;\n      } else {\n        const option1 = a_end - b_start;\n        const option2 = b_end - a_start;\n\n        overlap = option1 < option2 ? option1 : -option2;\n      }\n    } else {\n      result.b_in_a = false;\n\n      if (a_end > b_end) {\n        overlap = a_start - b_end;\n        result.a_in_b = false;\n      } else {\n        const option1 = a_end - b_start;\n        const option2 = b_end - a_start;\n\n        overlap = option1 < option2 ? option1 : -option2;\n      }\n    }\n\n    const current_overlap = result.overlap;\n    const absolute_overlap = overlap < 0 ? -overlap : overlap;\n\n    if (current_overlap === null || current_overlap > absolute_overlap) {\n      const sign = overlap < 0 ? -1 : 1;\n\n      result.overlap = absolute_overlap;\n      result.overlap_x = x * sign;\n      result.overlap_y = y * sign;\n    }\n  }\n\n  return false;\n}\n\nmodule.exports = SAT;\n\nmodule.exports[\"default\"] = module.exports;\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/SAT.js?");

/***/ }),

/***/ "./source/modules/index.js":
/*!*********************************!*\
  !*** ./source/modules/index.js ***!
  \*********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const BVH = __webpack_require__(/*! ./BVH.js */ \"./source/modules/BVH.js\");\nconst Circle = __webpack_require__(/*! ./Circle.js */ \"./source/modules/Circle.js\");\nconst Polygon = __webpack_require__(/*! ./Polygon.js */ \"./source/modules/Polygon.js\");\nconst Point = __webpack_require__(/*! ./Point.js */ \"./source/modules/Point.js\");\nconst Result = __webpack_require__(/*! ./Result.js */ \"./source/modules/Result.js\");\nconst SAT = __webpack_require__(/*! ./SAT.js */ \"./source/modules/SAT.js\");\n\nmodule.exports = {\n  BVH,\n  Circle,\n  Polygon,\n  Point,\n  Result,\n  SAT,\n};\n\n\n//# sourceURL=webpack://detect-collisions/./source/modules/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./demo/index.js");
/******/ 	
/******/ })()
;