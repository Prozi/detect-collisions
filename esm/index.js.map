{"version":3,"file":"index.js","sources":["../node_modules/sat/SAT.js","../src/external/quickselect.js","../src/external/rbush.js","../node_modules/poly-decomp-es/dist/poly-decomp-es.js","../src/model.ts","../src/optimized.ts","../src/intersect.ts","../src/utils.ts","../src/bodies/circle.ts","../src/bodies/polygon.ts","../src/bodies/ellipse.ts","../src/bodies/box.ts","../src/bodies/point.ts","../src/bodies/line.ts","../src/base-system.ts","../src/system.ts"],"sourcesContent":["// Version 0.9.0 - Copyright 2012 - 2021 -  Jim Riecken <jimr@jimr.ca>\n//\n// Released under the MIT License - https://github.com/jriecken/sat-js\n//\n// A simple library for determining intersections of circles and\n// polygons using the Separating Axis Theorem.\n/** @preserve SAT.js - Version 0.9.0 - Copyright 2012 - 2021 - Jim Riecken <jimr@jimr.ca> - released under the MIT License. https://github.com/jriecken/sat-js */\n\n/*global define: false, module: false*/\n/*jshint shadow:true, sub:true, forin:true, noarg:true, noempty:true,\n  eqeqeq:true, bitwise:true, strict:true, undef:true,\n  curly:true, browser:true */\n\n// Create a UMD wrapper for SAT. Works in:\n//\n//  - Plain browser via global SAT variable\n//  - AMD loader (like require.js)\n//  - Node.js\n//\n// The quoted properties all over the place are used so that the Closure Compiler\n// does not mangle the exposed API in advanced mode.\n/**\n * @param {*} root - The global scope\n * @param {Function} factory - Factory that creates SAT module\n */\n(function (root, factory) {\n  \"use strict\";\n  if (typeof define === 'function' && define['amd']) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module['exports'] = factory();\n  } else {\n    root['SAT'] = factory();\n  }\n}(this, function () {\n  \"use strict\";\n\n  var SAT = {};\n\n  //\n  // ## Vector\n  //\n  // Represents a vector in two dimensions with `x` and `y` properties.\n\n\n  // Create a new Vector, optionally passing in the `x` and `y` coordinates. If\n  // a coordinate is not specified, it will be set to `0`\n  /**\n   * @param {?number=} x The x position.\n   * @param {?number=} y The y position.\n   * @constructor\n   */\n  function Vector(x, y) {\n    this['x'] = x || 0;\n    this['y'] = y || 0;\n  }\n  SAT['Vector'] = Vector;\n  // Alias `Vector` as `V`\n  SAT['V'] = Vector;\n\n\n  // Copy the values of another Vector into this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['copy'] = Vector.prototype.copy = function (other) {\n    this['x'] = other['x'];\n    this['y'] = other['y'];\n    return this;\n  };\n\n  // Create a new vector with the same coordinates as this on.\n  /**\n   * @return {Vector} The new cloned vector\n   */\n  Vector.prototype['clone'] = Vector.prototype.clone = function () {\n    return new Vector(this['x'], this['y']);\n  };\n\n  // Change this vector to be perpendicular to what it was before. (Effectively\n  // roatates it 90 degrees in a clockwise direction)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['perp'] = Vector.prototype.perp = function () {\n    var x = this['x'];\n    this['x'] = this['y'];\n    this['y'] = -x;\n    return this;\n  };\n\n  // Rotate this vector (counter-clockwise) by the specified angle (in radians).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['rotate'] = Vector.prototype.rotate = function (angle) {\n    var x = this['x'];\n    var y = this['y'];\n    this['x'] = x * Math.cos(angle) - y * Math.sin(angle);\n    this['y'] = x * Math.sin(angle) + y * Math.cos(angle);\n    return this;\n  };\n\n  // Reverse this vector.\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reverse'] = Vector.prototype.reverse = function () {\n    this['x'] = -this['x'];\n    this['y'] = -this['y'];\n    return this;\n  };\n\n\n  // Normalize this vector.  (make it have length of `1`)\n  /**\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['normalize'] = Vector.prototype.normalize = function () {\n    var d = this.len();\n    if (d > 0) {\n      this['x'] = this['x'] / d;\n      this['y'] = this['y'] / d;\n    }\n    return this;\n  };\n\n  // Add another vector to this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['add'] = Vector.prototype.add = function (other) {\n    this['x'] += other['x'];\n    this['y'] += other['y'];\n    return this;\n  };\n\n  // Subtract another vector from this one.\n  /**\n   * @param {Vector} other The other Vector.\n   * @return {Vector} This for chaiing.\n   */\n  Vector.prototype['sub'] = Vector.prototype.sub = function (other) {\n    this['x'] -= other['x'];\n    this['y'] -= other['y'];\n    return this;\n  };\n\n  // Scale this vector. An independent scaling factor can be provided\n  // for each axis, or a single scaling factor that will scale both `x` and `y`.\n  /**\n   * @param {number} x The scaling factor in the x direction.\n   * @param {?number=} y The scaling factor in the y direction.  If this\n   *   is not specified, the x scaling factor will be used.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['scale'] = Vector.prototype.scale = function (x, y) {\n    this['x'] *= x;\n    this['y'] *= typeof y != 'undefined' ? y : x;\n    return this;\n  };\n\n  // Project this vector on to another vector.\n  /**\n   * @param {Vector} other The vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['project'] = Vector.prototype.project = function (other) {\n    var amt = this.dot(other) / other.len2();\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Project this vector onto a vector of unit length. This is slightly more efficient\n  // than `project` when dealing with unit vectors.\n  /**\n   * @param {Vector} other The unit vector to project onto.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['projectN'] = Vector.prototype.projectN = function (other) {\n    var amt = this.dot(other);\n    this['x'] = amt * other['x'];\n    this['y'] = amt * other['y'];\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis.\n  /**\n   * @param {Vector} axis The vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflect'] = Vector.prototype.reflect = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.project(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Reflect this vector on an arbitrary axis (represented by a unit vector). This is\n  // slightly more efficient than `reflect` when dealing with an axis that is a unit vector.\n  /**\n   * @param {Vector} axis The unit vector representing the axis.\n   * @return {Vector} This for chaining.\n   */\n  Vector.prototype['reflectN'] = Vector.prototype.reflectN = function (axis) {\n    var x = this['x'];\n    var y = this['y'];\n    this.projectN(axis).scale(2);\n    this['x'] -= x;\n    this['y'] -= y;\n    return this;\n  };\n\n  // Get the dot product of this vector and another.\n  /**\n   * @param {Vector}  other The vector to dot this one against.\n   * @return {number} The dot product.\n   */\n  Vector.prototype['dot'] = Vector.prototype.dot = function (other) {\n    return this['x'] * other['x'] + this['y'] * other['y'];\n  };\n\n  // Get the squared length of this vector.\n  /**\n   * @return {number} The length^2 of this vector.\n   */\n  Vector.prototype['len2'] = Vector.prototype.len2 = function () {\n    return this.dot(this);\n  };\n\n  // Get the length of this vector.\n  /**\n   * @return {number} The length of this vector.\n   */\n  Vector.prototype['len'] = Vector.prototype.len = function () {\n    return Math.sqrt(this.len2());\n  };\n\n  // ## Circle\n  //\n  // Represents a circle with a position and a radius.\n\n  // Create a new circle, optionally passing in a position and/or radius. If no position\n  // is given, the circle will be at `(0,0)`. If no radius is provided, the circle will\n  // have a radius of `0`.\n  /**\n   * @param {Vector=} pos A vector representing the position of the center of the circle\n   * @param {?number=} r The radius of the circle\n   * @constructor\n   */\n  function Circle(pos, r) {\n    this['pos'] = pos || new Vector();\n    this['r'] = r || 0;\n    this['offset'] = new Vector();\n  }\n  SAT['Circle'] = Circle;\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABBAsBox'] = Circle.prototype.getAABBAsBox = function () {\n    var r = this['r'];\n    var corner = this['pos'].clone().add(this['offset']).sub(new Vector(r, r));\n    return new Box(corner, r * 2, r * 2);\n  };\n\n  // Compute the axis-aligned bounding box (AABB) of this Circle.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Circle.prototype['getAABB'] = Circle.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Set the current offset to apply to the radius.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Circle} This for chaining.\n   */\n  Circle.prototype['setOffset'] = Circle.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    return this;\n  };\n\n  // ## Polygon\n  //\n  // Represents a *convex* polygon with any number of points (specified in counter-clockwise order)\n  //\n  // Note: Do _not_ manually change the `points`, `angle`, or `offset` properties. Use the\n  // provided setters. Otherwise the calculated properties will not be updated correctly.\n  //\n  // `pos` can be changed directly.\n\n  // Create a new polygon, passing in a position vector, and an array of points (represented\n  // by vectors relative to the position vector). If no position is passed in, the position\n  // of the polygon will be `(0,0)`.\n  /**\n   * @param {Vector=} pos A vector representing the origin of the polygon. (all other\n   *   points are relative to this one)\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @constructor\n   */\n  function Polygon(pos, points) {\n    this['pos'] = pos || new Vector();\n    this['angle'] = 0;\n    this['offset'] = new Vector();\n    this.setPoints(points || []);\n  }\n  SAT['Polygon'] = Polygon;\n\n  // Set the points of the polygon. Any consecutive duplicate points will be combined.\n  //\n  // Note: The points are counter-clockwise *with respect to the coordinate system*.\n  // If you directly draw the points on a screen that has the origin at the top-left corner\n  // it will _appear_ visually that the points are being specified clockwise. This is just\n  // because of the inversion of the Y-axis when being displayed.\n  /**\n   * @param {Array<Vector>=} points An array of vectors representing the points in the polygon,\n   *   in counter-clockwise order.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setPoints'] = Polygon.prototype.setPoints = function (points) {\n    // Only re-allocate if this is a new polygon or the number of points has changed.\n    var lengthChanged = !this['points'] || this['points'].length !== points.length;\n    if (lengthChanged) {\n      var i;\n      var calcPoints = this['calcPoints'] = [];\n      var edges = this['edges'] = [];\n      var normals = this['normals'] = [];\n      // Allocate the vector arrays for the calculated properties\n      for (i = 0; i < points.length; i++) {\n        // Remove consecutive duplicate points\n        var p1 = points[i];\n        var p2 = i < points.length - 1 ? points[i + 1] : points[0];\n        if (p1 !== p2 && p1.x === p2.x && p1.y === p2.y) {\n          points.splice(i, 1);\n          i -= 1;\n          continue;\n        }\n        calcPoints.push(new Vector());\n        edges.push(new Vector());\n        normals.push(new Vector());\n      }\n    }\n    this['points'] = points;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current rotation angle of the polygon.\n  /**\n   * @param {number} angle The current rotation angle (in radians).\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setAngle'] = Polygon.prototype.setAngle = function (angle) {\n    this['angle'] = angle;\n    this._recalc();\n    return this;\n  };\n\n  // Set the current offset to apply to the `points` before applying the `angle` rotation.\n  /**\n   * @param {Vector} offset The new offset vector.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['setOffset'] = Polygon.prototype.setOffset = function (offset) {\n    this['offset'] = offset;\n    this._recalc();\n    return this;\n  };\n\n  // Rotates this polygon counter-clockwise around the origin of *its local coordinate system* (i.e. `pos`).\n  //\n  // Note: This changes the **original** points (so any `angle` will be applied on top of this rotation).\n  /**\n   * @param {number} angle The angle to rotate (in radians)\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['rotate'] = Polygon.prototype.rotate = function (angle) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i].rotate(angle);\n    }\n    this._recalc();\n    return this;\n  };\n\n  // Translates the points of this polygon by a specified amount relative to the origin of *its own coordinate\n  // system* (i.e. `pos`).\n  //\n  // This is most useful to change the \"center point\" of a polygon. If you just want to move the whole polygon, change\n  // the coordinates of `pos`.\n  //\n  // Note: This changes the **original** points (so any `offset` will be applied on top of this translation)\n  /**\n   * @param {number} x The horizontal amount to translate.\n   * @param {number} y The vertical amount to translate.\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype['translate'] = Polygon.prototype.translate = function (x, y) {\n    var points = this['points'];\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      points[i]['x'] += x;\n      points[i]['y'] += y;\n    }\n    this._recalc();\n    return this;\n  };\n\n\n  // Computes the calculated collision polygon. Applies the `angle` and `offset` to the original points then recalculates the\n  // edges and normals of the collision polygon.\n  /**\n   * @return {Polygon} This for chaining.\n   */\n  Polygon.prototype._recalc = function () {\n    // Calculated points - this is what is used for underlying collisions and takes into account\n    // the angle/offset set on the polygon.\n    var calcPoints = this['calcPoints'];\n    // The edges here are the direction of the `n`th edge of the polygon, relative to\n    // the `n`th point. If you want to draw a given edge from the edge value, you must\n    // first translate to the position of the starting point.\n    var edges = this['edges'];\n    // The normals here are the direction of the normal for the `n`th edge of the polygon, relative\n    // to the position of the `n`th point. If you want to draw an edge normal, you must first\n    // translate to the position of the starting point.\n    var normals = this['normals'];\n    // Copy the original points array and apply the offset/angle\n    var points = this['points'];\n    var offset = this['offset'];\n    var angle = this['angle'];\n    var len = points.length;\n    var i;\n    for (i = 0; i < len; i++) {\n      var calcPoint = calcPoints[i].copy(points[i]);\n      calcPoint['x'] += offset['x'];\n      calcPoint['y'] += offset['y'];\n      if (angle !== 0) {\n        calcPoint.rotate(angle);\n      }\n    }\n    // Calculate the edges/normals\n    for (i = 0; i < len; i++) {\n      var p1 = calcPoints[i];\n      var p2 = i < len - 1 ? calcPoints[i + 1] : calcPoints[0];\n      var e = edges[i].copy(p2).sub(p1);\n      normals[i].copy(e).perp().normalize();\n    }\n    return this;\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Box` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABBAsBox'] = Polygon.prototype.getAABBAsBox = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var xMin = points[0]['x'];\n    var yMin = points[0]['y'];\n    var xMax = points[0]['x'];\n    var yMax = points[0]['y'];\n    for (var i = 1; i < len; i++) {\n      var point = points[i];\n      if (point['x'] < xMin) {\n        xMin = point['x'];\n      }\n      else if (point['x'] > xMax) {\n        xMax = point['x'];\n      }\n      if (point['y'] < yMin) {\n        yMin = point['y'];\n      }\n      else if (point['y'] > yMax) {\n        yMax = point['y'];\n      }\n    }\n    return new Box(this['pos'].clone().add(new Vector(xMin, yMin)), xMax - xMin, yMax - yMin);\n  };\n\n\n  // Compute the axis-aligned bounding box. Any current state\n  // (translations/rotations) will be applied before constructing the AABB.\n  //\n  // Note: Returns a _new_ `Polygon` each time you call this.\n  /**\n   * @return {Polygon} The AABB\n   */\n  Polygon.prototype['getAABB'] = Polygon.prototype.getAABB = function () {\n    return this.getAABBAsBox().toPolygon();\n  };\n\n  // Compute the centroid (geometric center) of the polygon. Any current state\n  // (translations/rotations) will be applied before computing the centroid.\n  //\n  // See https://en.wikipedia.org/wiki/Centroid#Centroid_of_a_polygon\n  //\n  // Note: Returns a _new_ `Vector` each time you call this.\n  /**\n   * @return {Vector} A Vector that contains the coordinates of the Centroid.\n   */\n  Polygon.prototype['getCentroid'] = Polygon.prototype.getCentroid = function () {\n    var points = this['calcPoints'];\n    var len = points.length;\n    var cx = 0;\n    var cy = 0;\n    var ar = 0;\n    for (var i = 0; i < len; i++) {\n      var p1 = points[i];\n      var p2 = i === len - 1 ? points[0] : points[i + 1]; // Loop around if last point\n      var a = p1['x'] * p2['y'] - p2['x'] * p1['y'];\n      cx += (p1['x'] + p2['x']) * a;\n      cy += (p1['y'] + p2['y']) * a;\n      ar += a;\n    }\n    ar = ar * 3; // we want 1 / 6 the area and we currently have 2*area\n    cx = cx / ar;\n    cy = cy / ar;\n    return new Vector(cx, cy);\n  };\n\n\n  // ## Box\n  //\n  // Represents an axis-aligned box, with a width and height.\n\n\n  // Create a new box, with the specified position, width, and height. If no position\n  // is given, the position will be `(0,0)`. If no width or height are given, they will\n  // be set to `0`.\n  /**\n   * @param {Vector=} pos A vector representing the bottom-left of the box (i.e. the smallest x and smallest y value).\n   * @param {?number=} w The width of the box.\n   * @param {?number=} h The height of the box.\n   * @constructor\n   */\n  function Box(pos, w, h) {\n    this['pos'] = pos || new Vector();\n    this['w'] = w || 0;\n    this['h'] = h || 0;\n  }\n  SAT['Box'] = Box;\n\n  // Returns a polygon whose edges are the same as this box.\n  /**\n   * @return {Polygon} A new Polygon that represents this box.\n   */\n  Box.prototype['toPolygon'] = Box.prototype.toPolygon = function () {\n    var pos = this['pos'];\n    var w = this['w'];\n    var h = this['h'];\n    return new Polygon(new Vector(pos['x'], pos['y']), [\n      new Vector(), new Vector(w, 0),\n      new Vector(w, h), new Vector(0, h)\n    ]);\n  };\n\n  // ## Response\n  //\n  // An object representing the result of an intersection. Contains:\n  //  - The two objects participating in the intersection\n  //  - The vector representing the minimum change necessary to extract the first object\n  //    from the second one (as well as a unit vector in that direction and the magnitude\n  //    of the overlap)\n  //  - Whether the first object is entirely inside the second, and vice versa.\n  /**\n   * @constructor\n   */\n  function Response() {\n    this['a'] = null;\n    this['b'] = null;\n    this['overlapN'] = new Vector();\n    this['overlapV'] = new Vector();\n    this.clear();\n  }\n  SAT['Response'] = Response;\n\n  // Set some values of the response back to their defaults.  Call this between tests if\n  // you are going to reuse a single Response object for multiple intersection tests (recommented\n  // as it will avoid allcating extra memory)\n  /**\n   * @return {Response} This for chaining\n   */\n  Response.prototype['clear'] = Response.prototype.clear = function () {\n    this['aInB'] = true;\n    this['bInA'] = true;\n    this['overlap'] = Number.MAX_VALUE;\n    return this;\n  };\n\n  // ## Object Pools\n\n  // A pool of `Vector` objects that are used in calculations to avoid\n  // allocating memory.\n  /**\n   * @type {Array<Vector>}\n   */\n  var T_VECTORS = [];\n  for (var i = 0; i < 10; i++) { T_VECTORS.push(new Vector()); }\n\n  // A pool of arrays of numbers used in calculations to avoid allocating\n  // memory.\n  /**\n   * @type {Array<Array<number>>}\n   */\n  var T_ARRAYS = [];\n  for (var i = 0; i < 5; i++) { T_ARRAYS.push([]); }\n\n  // Temporary response used for polygon hit detection.\n  /**\n   * @type {Response}\n   */\n  var T_RESPONSE = new Response();\n\n  // Tiny \"point\" polygon used for polygon hit detection.\n  /**\n   * @type {Polygon}\n   */\n  var TEST_POINT = new Box(new Vector(), 0.000001, 0.000001).toPolygon();\n\n  // ## Helper Functions\n\n  // Flattens the specified array of points onto a unit vector axis,\n  // resulting in a one dimensional range of the minimum and\n  // maximum value on that axis.\n  /**\n   * @param {Array<Vector>} points The points to flatten.\n   * @param {Vector} normal The unit vector axis to flatten on.\n   * @param {Array<number>} result An array.  After calling this function,\n   *   result[0] will be the minimum value,\n   *   result[1] will be the maximum value.\n   */\n  function flattenPointsOn(points, normal, result) {\n    var min = Number.MAX_VALUE;\n    var max = -Number.MAX_VALUE;\n    var len = points.length;\n    for (var i = 0; i < len; i++) {\n      // The magnitude of the projection of the point onto the normal\n      var dot = points[i].dot(normal);\n      if (dot < min) { min = dot; }\n      if (dot > max) { max = dot; }\n    }\n    result[0] = min; result[1] = max;\n  }\n\n  // Check whether two convex polygons are separated by the specified\n  // axis (must be a unit vector).\n  /**\n   * @param {Vector} aPos The position of the first polygon.\n   * @param {Vector} bPos The position of the second polygon.\n   * @param {Array<Vector>} aPoints The points in the first polygon.\n   * @param {Array<Vector>} bPoints The points in the second polygon.\n   * @param {Vector} axis The axis (unit sized) to test against.  The points of both polygons\n   *   will be projected onto this axis.\n   * @param {Response=} response A Response object (optional) which will be populated\n   *   if the axis is not a separating axis.\n   * @return {boolean} true if it is a separating axis, false otherwise.  If false,\n   *   and a response is passed in, information about how much overlap and\n   *   the direction of the overlap will be populated.\n   */\n  function isSeparatingAxis(aPos, bPos, aPoints, bPoints, axis, response) {\n    var rangeA = T_ARRAYS.pop();\n    var rangeB = T_ARRAYS.pop();\n    // The magnitude of the offset between the two polygons\n    var offsetV = T_VECTORS.pop().copy(bPos).sub(aPos);\n    var projectedOffset = offsetV.dot(axis);\n    // Project the polygons onto the axis.\n    flattenPointsOn(aPoints, axis, rangeA);\n    flattenPointsOn(bPoints, axis, rangeB);\n    // Move B's range to its position relative to A.\n    rangeB[0] += projectedOffset;\n    rangeB[1] += projectedOffset;\n    // Check if there is a gap. If there is, this is a separating axis and we can stop\n    if (rangeA[0] > rangeB[1] || rangeB[0] > rangeA[1]) {\n      T_VECTORS.push(offsetV);\n      T_ARRAYS.push(rangeA);\n      T_ARRAYS.push(rangeB);\n      return true;\n    }\n    // This is not a separating axis. If we're calculating a response, calculate the overlap.\n    if (response) {\n      var overlap = 0;\n      // A starts further left than B\n      if (rangeA[0] < rangeB[0]) {\n        response['aInB'] = false;\n        // A ends before B does. We have to pull A out of B\n        if (rangeA[1] < rangeB[1]) {\n          overlap = rangeA[1] - rangeB[0];\n          response['bInA'] = false;\n          // B is fully inside A.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n        // B starts further left than A\n      } else {\n        response['bInA'] = false;\n        // B ends before A ends. We have to push A out of B\n        if (rangeA[1] > rangeB[1]) {\n          overlap = rangeA[0] - rangeB[1];\n          response['aInB'] = false;\n          // A is fully inside B.  Pick the shortest way out.\n        } else {\n          var option1 = rangeA[1] - rangeB[0];\n          var option2 = rangeB[1] - rangeA[0];\n          overlap = option1 < option2 ? option1 : -option2;\n        }\n      }\n      // If this is the smallest amount of overlap we've seen so far, set it as the minimum overlap.\n      var absOverlap = Math.abs(overlap);\n      if (absOverlap < response['overlap']) {\n        response['overlap'] = absOverlap;\n        response['overlapN'].copy(axis);\n        if (overlap < 0) {\n          response['overlapN'].reverse();\n        }\n      }\n    }\n    T_VECTORS.push(offsetV);\n    T_ARRAYS.push(rangeA);\n    T_ARRAYS.push(rangeB);\n    return false;\n  }\n  SAT['isSeparatingAxis'] = isSeparatingAxis;\n\n  // Calculates which Voronoi region a point is on a line segment.\n  // It is assumed that both the line and the point are relative to `(0,0)`\n  //\n  //            |       (0)      |\n  //     (-1)  [S]--------------[E]  (1)\n  //            |       (0)      |\n  /**\n   * @param {Vector} line The line segment.\n   * @param {Vector} point The point.\n   * @return  {number} LEFT_VORONOI_REGION (-1) if it is the left region,\n   *          MIDDLE_VORONOI_REGION (0) if it is the middle region,\n   *          RIGHT_VORONOI_REGION (1) if it is the right region.\n   */\n  function voronoiRegion(line, point) {\n    var len2 = line.len2();\n    var dp = point.dot(line);\n    // If the point is beyond the start of the line, it is in the\n    // left voronoi region.\n    if (dp < 0) { return LEFT_VORONOI_REGION; }\n    // If the point is beyond the end of the line, it is in the\n    // right voronoi region.\n    else if (dp > len2) { return RIGHT_VORONOI_REGION; }\n    // Otherwise, it's in the middle one.\n    else { return MIDDLE_VORONOI_REGION; }\n  }\n  // Constants for Voronoi regions\n  /**\n   * @const\n   */\n  var LEFT_VORONOI_REGION = -1;\n  /**\n   * @const\n   */\n  var MIDDLE_VORONOI_REGION = 0;\n  /**\n   * @const\n   */\n  var RIGHT_VORONOI_REGION = 1;\n\n  // ## Collision Tests\n\n  // Check if a point is inside a circle.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Circle} c The circle to test.\n   * @return {boolean} true if the point is inside the circle, false if it is not.\n   */\n  function pointInCircle(p, c) {\n    var differenceV = T_VECTORS.pop().copy(p).sub(c['pos']).sub(c['offset']);\n    var radiusSq = c['r'] * c['r'];\n    var distanceSq = differenceV.len2();\n    T_VECTORS.push(differenceV);\n    // If the distance between is smaller than the radius then the point is inside the circle.\n    return distanceSq <= radiusSq;\n  }\n  SAT['pointInCircle'] = pointInCircle;\n\n  // Check if a point is inside a convex polygon.\n  /**\n   * @param {Vector} p The point to test.\n   * @param {Polygon} poly The polygon to test.\n   * @return {boolean} true if the point is inside the polygon, false if it is not.\n   */\n  function pointInPolygon(p, poly) {\n    TEST_POINT['pos'].copy(p);\n    T_RESPONSE.clear();\n    var result = testPolygonPolygon(TEST_POINT, poly, T_RESPONSE);\n    if (result) {\n      result = T_RESPONSE['aInB'];\n    }\n    return result;\n  }\n  SAT['pointInPolygon'] = pointInPolygon;\n\n  // Check if two circles collide.\n  /**\n   * @param {Circle} a The first circle.\n   * @param {Circle} b The second circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   the circles intersect.\n   * @return {boolean} true if the circles intersect, false if they don't.\n   */\n  function testCircleCircle(a, b, response) {\n    // Check if the distance between the centers of the two\n    // circles is greater than their combined radius.\n    var differenceV = T_VECTORS.pop().copy(b['pos']).add(b['offset']).sub(a['pos']).sub(a['offset']);\n    var totalRadius = a['r'] + b['r'];\n    var totalRadiusSq = totalRadius * totalRadius;\n    var distanceSq = differenceV.len2();\n    // If the distance is bigger than the combined radius, they don't intersect.\n    if (distanceSq > totalRadiusSq) {\n      T_VECTORS.push(differenceV);\n      return false;\n    }\n    // They intersect.  If we're calculating a response, calculate the overlap.\n    if (response) {\n      var dist = Math.sqrt(distanceSq);\n      response['a'] = a;\n      response['b'] = b;\n      response['overlap'] = totalRadius - dist;\n      response['overlapN'].copy(differenceV.normalize());\n      response['overlapV'].copy(differenceV).scale(response['overlap']);\n      response['aInB'] = a['r'] <= b['r'] && dist <= b['r'] - a['r'];\n      response['bInA'] = b['r'] <= a['r'] && dist <= a['r'] - b['r'];\n    }\n    T_VECTORS.push(differenceV);\n    return true;\n  }\n  SAT['testCircleCircle'] = testCircleCircle;\n\n  // Check if a polygon and a circle collide.\n  /**\n   * @param {Polygon} polygon The polygon.\n   * @param {Circle} circle The circle.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonCircle(polygon, circle, response) {\n    // Get the position of the circle relative to the polygon.\n    var circlePos = T_VECTORS.pop().copy(circle['pos']).add(circle['offset']).sub(polygon['pos']);\n    var radius = circle['r'];\n    var radius2 = radius * radius;\n    var points = polygon['calcPoints'];\n    var len = points.length;\n    var edge = T_VECTORS.pop();\n    var point = T_VECTORS.pop();\n\n    // For each edge in the polygon:\n    for (var i = 0; i < len; i++) {\n      var next = i === len - 1 ? 0 : i + 1;\n      var prev = i === 0 ? len - 1 : i - 1;\n      var overlap = 0;\n      var overlapN = null;\n\n      // Get the edge.\n      edge.copy(polygon['edges'][i]);\n      // Calculate the center of the circle relative to the starting point of the edge.\n      point.copy(circlePos).sub(points[i]);\n\n      // If the distance between the center of the circle and the point\n      // is bigger than the radius, the polygon is definitely not fully in\n      // the circle.\n      if (response && point.len2() > radius2) {\n        response['aInB'] = false;\n      }\n\n      // Calculate which Voronoi region the center of the circle is in.\n      var region = voronoiRegion(edge, point);\n      // If it's the left region:\n      if (region === LEFT_VORONOI_REGION) {\n        // We need to make sure we're in the RIGHT_VORONOI_REGION of the previous edge.\n        edge.copy(polygon['edges'][prev]);\n        // Calculate the center of the circle relative the starting point of the previous edge\n        var point2 = T_VECTORS.pop().copy(circlePos).sub(points[prev]);\n        region = voronoiRegion(edge, point2);\n        if (region === RIGHT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            T_VECTORS.push(point2);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        T_VECTORS.push(point2);\n        // If it's the right region:\n      } else if (region === RIGHT_VORONOI_REGION) {\n        // We need to make sure we're in the left region on the next edge\n        edge.copy(polygon['edges'][next]);\n        // Calculate the center of the circle relative to the starting point of the next edge.\n        point.copy(circlePos).sub(points[next]);\n        region = voronoiRegion(edge, point);\n        if (region === LEFT_VORONOI_REGION) {\n          // It's in the region we want.  Check if the circle intersects the point.\n          var dist = point.len();\n          if (dist > radius) {\n            // No intersection\n            T_VECTORS.push(circlePos);\n            T_VECTORS.push(edge);\n            T_VECTORS.push(point);\n            return false;\n          } else if (response) {\n            // It intersects, calculate the overlap.\n            response['bInA'] = false;\n            overlapN = point.normalize();\n            overlap = radius - dist;\n          }\n        }\n        // Otherwise, it's the middle region:\n      } else {\n        // Need to check if the circle is intersecting the edge,\n        // Change the edge into its \"edge normal\".\n        var normal = edge.perp().normalize();\n        // Find the perpendicular distance between the center of the\n        // circle and the edge.\n        var dist = point.dot(normal);\n        var distAbs = Math.abs(dist);\n        // If the circle is on the outside of the edge, there is no intersection.\n        if (dist > 0 && distAbs > radius) {\n          // No intersection\n          T_VECTORS.push(circlePos);\n          T_VECTORS.push(normal);\n          T_VECTORS.push(point);\n          return false;\n        } else if (response) {\n          // It intersects, calculate the overlap.\n          overlapN = normal;\n          overlap = radius - dist;\n          // If the center of the circle is on the outside of the edge, or part of the\n          // circle is on the outside, the circle is not fully inside the polygon.\n          if (dist >= 0 || overlap < 2 * radius) {\n            response['bInA'] = false;\n          }\n        }\n      }\n\n      // If this is the smallest overlap we've seen, keep it.\n      // (overlapN may be null if the circle was in the wrong Voronoi region).\n      if (overlapN && response && Math.abs(overlap) < Math.abs(response['overlap'])) {\n        response['overlap'] = overlap;\n        response['overlapN'].copy(overlapN);\n      }\n    }\n\n    // Calculate the final overlap vector - based on the smallest overlap.\n    if (response) {\n      response['a'] = polygon;\n      response['b'] = circle;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    T_VECTORS.push(circlePos);\n    T_VECTORS.push(edge);\n    T_VECTORS.push(point);\n    return true;\n  }\n  SAT['testPolygonCircle'] = testPolygonCircle;\n\n  // Check if a circle and a polygon collide.\n  //\n  // **NOTE:** This is slightly less efficient than polygonCircle as it just\n  // runs polygonCircle and reverses everything at the end.\n  /**\n   * @param {Circle} circle The circle.\n   * @param {Polygon} polygon The polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testCirclePolygon(circle, polygon, response) {\n    // Test the polygon against the circle.\n    var result = testPolygonCircle(polygon, circle, response);\n    if (result && response) {\n      // Swap A and B in the response.\n      var a = response['a'];\n      var aInB = response['aInB'];\n      response['overlapN'].reverse();\n      response['overlapV'].reverse();\n      response['a'] = response['b'];\n      response['b'] = a;\n      response['aInB'] = response['bInA'];\n      response['bInA'] = aInB;\n    }\n    return result;\n  }\n  SAT['testCirclePolygon'] = testCirclePolygon;\n\n  // Checks whether polygons collide.\n  /**\n   * @param {Polygon} a The first polygon.\n   * @param {Polygon} b The second polygon.\n   * @param {Response=} response Response object (optional) that will be populated if\n   *   they interset.\n   * @return {boolean} true if they intersect, false if they don't.\n   */\n  function testPolygonPolygon(a, b, response) {\n    var aPoints = a['calcPoints'];\n    var aLen = aPoints.length;\n    var bPoints = b['calcPoints'];\n    var bLen = bPoints.length;\n    // If any of the edge normals of A is a separating axis, no intersection.\n    for (var i = 0; i < aLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, a['normals'][i], response)) {\n        return false;\n      }\n    }\n    // If any of the edge normals of B is a separating axis, no intersection.\n    for (var i = 0; i < bLen; i++) {\n      if (isSeparatingAxis(a['pos'], b['pos'], aPoints, bPoints, b['normals'][i], response)) {\n        return false;\n      }\n    }\n    // Since none of the edge normals of A or B are a separating axis, there is an intersection\n    // and we've already calculated the smallest overlap (in isSeparatingAxis).  Calculate the\n    // final overlap vector.\n    if (response) {\n      response['a'] = a;\n      response['b'] = b;\n      response['overlapV'].copy(response['overlapN']).scale(response['overlap']);\n    }\n    return true;\n  }\n  SAT['testPolygonPolygon'] = testPolygonPolygon;\n\n  return SAT;\n}));\n","\n/**\n * Rearranges items so that all items in the [left, k] are the smallest.\n * The k-th element will have the (k - left + 1)-th smallest value in [left, right].\n *\n * @template T\n * @param {T[]} arr the array to partially sort (in place)\n * @param {number} k middle index for partial sorting (as defined above)\n * @param {number} [left=0] left index of the range to sort\n * @param {number} [right=arr.length-1] right index\n * @param {(a: T, b: T) => number} [compare = (a, b) => a - b] compare function\n */\nexport default function quickselect(arr, k, left = 0, right = arr.length - 1, compare = defaultCompare) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            const n = right - left + 1;\n            const m = k - left + 1;\n            const z = Math.log(n);\n            const s = 0.5 * Math.exp(2 * z / 3);\n            const sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            const newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            const newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            quickselect(arr, k, newLeft, newRight, compare);\n        }\n\n        const t = arr[k];\n        let i = left;\n        /** @type {number} */\n        let j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\n/**\n * @template T\n * @param {T[]} arr\n * @param {number} i\n * @param {number} j\n */\nfunction swap(arr, i, j) {\n    const tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\n/**\n * @template T\n * @param {T} a\n * @param {T} b\n * @returns {number}\n */\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n","import quickselect from './quickselect';\n\nexport default class RBush {\n    constructor(maxEntries = 9) {\n        // max entries in a node is 9 by default; min node fill is 40% for best performance\n        this._maxEntries = Math.max(4, maxEntries);\n        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n        this.clear();\n    }\n\n    all() {\n        return this._all(this.data, []);\n    }\n\n    search(bbox) {\n        let node = this.data;\n        const result = [];\n\n        if (!intersects(bbox, node)) return result;\n\n        const toBBox = this.toBBox;\n        const nodesToSearch = [];\n\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    }\n\n    collides(bbox) {\n        let node = this.data;\n\n        if (!intersects(bbox, node)) return false;\n\n        const nodesToSearch = [];\n        while (node) {\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const childBBox = node.leaf ? this.toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    }\n\n    load(data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (let i = 0; i < data.length; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from scratch using OMT algorithm\n        let node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                const tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    }\n\n    insert(item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    }\n\n    clear() {\n        this.data = createNode([]);\n        return this;\n    }\n\n    remove(item, equalsFn) {\n        if (!item) return this;\n\n        let node = this.data;\n        const bbox = this.toBBox(item);\n        const path = [];\n        const indexes = [];\n        let i, parent, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                const index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    }\n\n    toBBox(item) { return item; }\n\n    compareMinX(a, b) { return a.minX - b.minX; }\n    compareMinY(a, b) { return a.minY - b.minY; }\n\n    toJSON() { return this.data; }\n\n    fromJSON(data) {\n        this.data = data;\n        return this;\n    }\n\n    _all(node, result) {\n        const nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push(...node.children);\n            else nodesToSearch.push(...node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    }\n\n    _build(items, left, right, height) {\n\n        const N = right - left + 1;\n        let M = this._maxEntries;\n        let node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        const N2 = Math.ceil(N / M);\n        const N1 = N2 * Math.ceil(Math.sqrt(M));\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (let i = left; i <= right; i += N1) {\n\n            const right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (let j = i; j <= right2; j += N2) {\n\n                const right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    }\n\n    _chooseSubtree(bbox, node, level, path) {\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            let minArea = Infinity;\n            let minEnlargement = Infinity;\n            let targetNode;\n\n            for (let i = 0; i < node.children.length; i++) {\n                const child = node.children[i];\n                const area = bboxArea(child);\n                const enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    }\n\n    _insert(item, level, isNode) {\n        const bbox = isNode ? item : this.toBBox(item);\n        const insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        const node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    }\n\n    // split overflowed node into two\n    _split(insertPath, level) {\n        const node = insertPath[level];\n        const M = node.children.length;\n        const m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        const splitIndex = this._chooseSplitIndex(node, m, M);\n\n        const newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    }\n\n    _splitRoot(node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    }\n\n    _chooseSplitIndex(node, m, M) {\n        let index;\n        let minOverlap = Infinity;\n        let minArea = Infinity;\n\n        for (let i = m; i <= M - m; i++) {\n            const bbox1 = distBBox(node, 0, i, this.toBBox);\n            const bbox2 = distBBox(node, i, M, this.toBBox);\n\n            const overlap = intersectionArea(bbox1, bbox2);\n            const area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index || M - m;\n    }\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis(node, m, M) {\n        const compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;\n        const compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;\n        const xMargin = this._allDistMargin(node, m, M, compareMinX);\n        const yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    }\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin(node, m, M, compare) {\n        node.children.sort(compare);\n\n        const toBBox = this.toBBox;\n        const leftBBox = distBBox(node, 0, m, toBBox);\n        const rightBBox = distBBox(node, M - m, M, toBBox);\n        let margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);\n\n        for (let i = m; i < M - m; i++) {\n            const child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (let i = M - m - 1; i >= m; i--) {\n            const child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    }\n\n    _adjustParentBBoxes(bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (let i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    }\n\n    _condense(path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (let i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    }\n}\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (let i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (let i = k; i < p; i++) {\n        const child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    const minX = Math.max(a.minX, b.minX);\n    const minY = Math.max(a.minY, b.minY);\n    const maxX = Math.min(a.maxX, b.maxX);\n    const maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    const stack = [left, right];\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        const mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n","const tmpPoint1 = [0, 0];\nconst tmpPoint2 = [0, 0];\nconst tmpLine1 = [[0, 0], [0, 0]];\nconst tmpLine2 = [[0, 0], [0, 0]];\n\n/**\n * Compute the intersection between two lines.\n * @param l1 Line vector 1\n * @param l2 Line vector 2\n * @param precision Precision to use when checking if the lines are parallel\n * @return The intersection point.\n */\nfunction lineInt(l1, l2, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  precision = precision || 0;\n  const i = [0, 0]; // point\n  const a1 = l1[1][1] - l1[0][1];\n  const b1 = l1[0][0] - l1[1][0];\n  const c1 = a1 * l1[0][0] + b1 * l1[0][1];\n  const a2 = l2[1][1] - l2[0][1];\n  const b2 = l2[0][0] - l2[1][0];\n  const c2 = a2 * l2[0][0] + b2 * l2[0][1];\n  const det = a1 * b2 - a2 * b1;\n  if (!scalarsEqual(det, 0, precision)) {\n    // lines are not parallel\n    i[0] = (b2 * c1 - b1 * c2) / det;\n    i[1] = (a1 * c2 - a2 * c1) / det;\n  }\n  return i;\n}\n\n/**\n * Checks if two line segments intersects.\n * @param p1 The start vertex of the first line segment.\n * @param p2 The end vertex of the first line segment.\n * @param q1 The start vertex of the second line segment.\n * @param q2 The end vertex of the second line segment.\n * @return True if the two line segments intersect\n */\nfunction lineSegmentsIntersect(p1, p2, q1, q2) {\n  const dx = p2[0] - p1[0];\n  const dy = p2[1] - p1[1];\n  const da = q2[0] - q1[0];\n  const db = q2[1] - q1[1];\n\n  // segments are parallel\n  if (da * dy - db * dx === 0) {\n    return false;\n  }\n  const s = (dx * (q1[1] - p1[1]) + dy * (p1[0] - q1[0])) / (da * dy - db * dx);\n  const t = (da * (p1[1] - q1[1]) + db * (q1[0] - p1[0])) / (db * dx - da * dy);\n  return s >= 0 && s <= 1 && t >= 0 && t <= 1;\n}\n\n/**\n * Get the area of a triangle spanned by the three given points. Note that the area will be negative if the points are not given in counter-clockwise order.\n * @param a point 1\n * @param b point 2\n * @param c point 3\n * @return the area of a triangle spanned by the three given points\n */\nfunction triangleArea(a, b, c) {\n  return (b[0] - a[0]) * (c[1] - a[1]) - (c[0] - a[0]) * (b[1] - a[1]);\n}\nfunction isLeft(a, b, c) {\n  return triangleArea(a, b, c) > 0;\n}\nfunction isLeftOn(a, b, c) {\n  return triangleArea(a, b, c) >= 0;\n}\nfunction isRight(a, b, c) {\n  return triangleArea(a, b, c) < 0;\n}\nfunction isRightOn(a, b, c) {\n  return triangleArea(a, b, c) <= 0;\n}\n\n/**\n * Check if three points are collinear\n * @param a point 1\n * @param b point 2\n * @param c point 3\n * @param thresholdAngle angle to use when comparing the vectors. The function will return true if the angle between the resulting vectors is less than this value. Use zero for max precision.\n * @return whether the points are collinear\n */\nfunction collinear(a, b, c, thresholdAngle) {\n  if (thresholdAngle === void 0) {\n    thresholdAngle = 0;\n  }\n  if (!thresholdAngle) {\n    return triangleArea(a, b, c) === 0;\n  } else {\n    const ab = tmpPoint1;\n    const bc = tmpPoint2;\n    ab[0] = b[0] - a[0];\n    ab[1] = b[1] - a[1];\n    bc[0] = c[0] - b[0];\n    bc[1] = c[1] - b[1];\n    const dot = ab[0] * bc[0] + ab[1] * bc[1];\n    const magA = Math.sqrt(ab[0] * ab[0] + ab[1] * ab[1]);\n    const magB = Math.sqrt(bc[0] * bc[0] + bc[1] * bc[1]);\n    const angle = Math.acos(dot / (magA * magB));\n    return angle < thresholdAngle;\n  }\n}\nfunction sqdist(a, b) {\n  const dx = b[0] - a[0];\n  const dy = b[1] - a[1];\n  return dx * dx + dy * dy;\n}\n\n/**\n * Get a vertex at position i. It does not matter if i is out of bounds, this function will just cycle.\n * @param i vertex position\n * @return vertex at position i\n */\nfunction polygonAt(polygon, i) {\n  const s = polygon.length;\n  return polygon[i < 0 ? i % s + s : i % s];\n}\n\n/**\n * Clear the polygon data\n */\nfunction polygonClear(polygon) {\n  polygon.length = 0;\n}\n\n/**\n * Append points \"from\" to \"to\" -1 from an other polygon \"poly\" onto this one.\n * @param polygon the polygon to append to\n * @param poly The polygon to get points from.\n * @param from The vertex index in \"poly\".\n * @param to The end vertex index in \"poly\". Note that this vertex is NOT included when appending.\n */\nfunction polygonAppend(polygon, poly, from, to) {\n  for (let i = from; i < to; i++) {\n    polygon.push(poly[i]);\n  }\n}\n\n/**\n * Make sure that the polygon vertices are ordered counter-clockwise.\n */\nfunction makeCCW(polygon) {\n  let br = 0;\n  const v = polygon;\n\n  // find bottom right point\n  for (let i = 1; i < polygon.length; ++i) {\n    if (v[i][1] < v[br][1] || v[i][1] === v[br][1] && v[i][0] > v[br][0]) {\n      br = i;\n    }\n  }\n\n  // reverse poly if clockwise\n  if (!isLeft(polygonAt(polygon, br - 1), polygonAt(polygon, br), polygonAt(polygon, br + 1))) {\n    polygonReverse(polygon);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Reverse the vertices in the polygon\n */\nfunction polygonReverse(polygon) {\n  const tmp = [];\n  const N = polygon.length;\n  for (let i = 0; i !== N; i++) {\n    tmp.push(polygon.pop());\n  }\n  for (let i = 0; i !== N; i++) {\n    polygon[i] = tmp[i];\n  }\n}\n\n/**\n * Check if a point in the polygon is a reflex point\n * @param i the point in the polygon to check\n * @return whether the given point in the polygon is a reflex point\n */\nfunction polygonIsReflex(polygon, i) {\n  return isRight(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1));\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @param a vertex index 1\n * @param b vertex index 2\n * @return whether two vertices in the polygon can see each other\n */\nfunction polygonCanSee(polygon, a, b) {\n  const l1 = tmpLine1;\n  const l2 = tmpLine2;\n  if (isLeftOn(polygonAt(polygon, a + 1), polygonAt(polygon, a), polygonAt(polygon, b)) && isRightOn(polygonAt(polygon, a - 1), polygonAt(polygon, a), polygonAt(polygon, b))) {\n    return false;\n  }\n  const dist = sqdist(polygonAt(polygon, a), polygonAt(polygon, b));\n  for (let i = 0; i !== polygon.length; ++i) {\n    // for each edge\n    if ((i + 1) % polygon.length === a || i === a) {\n      // ignore incident edges\n      continue;\n    }\n    if (isLeftOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i + 1)) && isRightOn(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i))) {\n      // if diag intersects an edge\n      l1[0] = polygonAt(polygon, a);\n      l1[1] = polygonAt(polygon, b);\n      l2[0] = polygonAt(polygon, i);\n      l2[1] = polygonAt(polygon, i + 1);\n      const p = lineInt(l1, l2);\n      if (sqdist(polygonAt(polygon, a), p) < dist) {\n        // if edge is blocking visibility to b\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Check if two vertices in the polygon can see each other\n * @param a vertex index 1\n * @param b vertex index 2\n * @return if two vertices in the polygon can see each other\n */\nfunction polygonCanSee2(polygon, a, b) {\n  // for each edge\n  for (let i = 0; i !== polygon.length; ++i) {\n    // ignore incident edges\n    if (i === a || i === b || (i + 1) % polygon.length === a || (i + 1) % polygon.length === b) {\n      continue;\n    }\n    if (lineSegmentsIntersect(polygonAt(polygon, a), polygonAt(polygon, b), polygonAt(polygon, i), polygonAt(polygon, i + 1))) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy the polygon from vertex i to vertex j.\n * @param i the start vertex to copy from\n * @param j the end vertex to copy from\n * @param targetPoly optional target polygon to save in.\n * @return the resulting copy.\n */\nfunction polygonCopy(polygon, i, j, targetPoly) {\n  if (targetPoly === void 0) {\n    targetPoly = [];\n  }\n  polygonClear(targetPoly);\n  if (i < j) {\n    // Insert all vertices from i to j\n    for (let k = i; k <= j; k++) {\n      targetPoly.push(polygon[k]);\n    }\n  } else {\n    // Insert vertices 0 to j\n    for (let k = 0; k <= j; k++) {\n      targetPoly.push(polygon[k]);\n    }\n\n    // Insert vertices i to end\n    for (let k = i; k < polygon.length; k++) {\n      targetPoly.push(polygon[k]);\n    }\n  }\n  return targetPoly;\n}\n\n/**\n * Decomposes the polygon into convex pieces. Returns a list of edges [[p1,p2],[p2,p3],...] that cuts the polygon.\n * Note that this algorithm has complexity O(N^4) and will be very slow for polygons with many vertices.\n * @return a list of edges that cuts the polygon\n */\nfunction getCutEdges(polygon) {\n  let min = [];\n  let tmp1;\n  let tmp2;\n  const tmpPoly = [];\n  let nDiags = Number.MAX_VALUE;\n  for (let i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(polygon, i)) {\n      for (let j = 0; j < polygon.length; ++j) {\n        if (polygonCanSee(polygon, i, j)) {\n          tmp1 = getCutEdges(polygonCopy(polygon, i, j, tmpPoly));\n          tmp2 = getCutEdges(polygonCopy(polygon, j, i, tmpPoly));\n          for (let k = 0; k < tmp2.length; k++) {\n            tmp1.push(tmp2[k]);\n          }\n          if (tmp1.length < nDiags) {\n            min = tmp1;\n            nDiags = tmp1.length;\n            min.push([polygonAt(polygon, i), polygonAt(polygon, j)]);\n          }\n        }\n      }\n    }\n  }\n  return min;\n}\n\n/**\n * Decomposes the polygon into one or more convex sub-Polygons.\n * @return An array of Polygon objects, or false if decomposition fails\n */\nfunction decomp(polygon) {\n  const edges = getCutEdges(polygon);\n  if (edges.length > 0) {\n    return slicePolygon(polygon, edges);\n  } else {\n    return [polygon];\n  }\n}\n\n/**\n * Slices the polygon given one or more cut edges. If given one, this function will return two polygons (false on failure). If many, an array of polygons.\n * @param cutEdges A list of edges, as returned by .getCutEdges()\n * @return the sliced polygons, or false if the operation was unsuccessful\n */\nfunction slicePolygon(polygon, cutEdges) {\n  if (cutEdges.length === 0) {\n    return [polygon];\n  }\n\n  // if given multiple edges\n  if (cutEdges instanceof Array && cutEdges.length && cutEdges[0] instanceof Array && cutEdges[0].length === 2 && cutEdges[0][0] instanceof Array) {\n    const polys = [polygon];\n    for (let i = 0; i < cutEdges.length; i++) {\n      const cutEdge = cutEdges[i];\n      // Cut all polys\n      for (let j = 0; j < polys.length; j++) {\n        const poly = polys[j];\n        const result = slicePolygon(poly, cutEdge);\n        if (result) {\n          // Found poly! Cut and quit\n          polys.splice(j, 1);\n          polys.push(result[0], result[1]);\n          break;\n        }\n      }\n    }\n    return polys;\n  } else {\n    // Was given one edge\n    const cutEdge = cutEdges;\n    const i = polygon.indexOf(cutEdge[0]);\n    const j = polygon.indexOf(cutEdge[1]);\n    if (i !== -1 && j !== -1) {\n      return [polygonCopy(polygon, i, j), polygonCopy(polygon, j, i)];\n    } else {\n      return false;\n    }\n  }\n}\n\n/**\n * Checks that the line segments of this polygon do not intersect each other.\n * @param polygon An array of vertices e.g. [[0,0],[0,1],...]\n * @return whether line segments of this polygon do not intersect each other.\n * @todo Should it check all segments with all others?\n */\nfunction isSimple(polygon) {\n  const path = polygon;\n  let i;\n\n  // Check\n  for (i = 0; i < path.length - 1; i++) {\n    for (let j = 0; j < i - 1; j++) {\n      if (lineSegmentsIntersect(path[i], path[i + 1], path[j], path[j + 1])) {\n        return false;\n      }\n    }\n  }\n\n  // Check the segment between the last and the first point to all others\n  for (i = 1; i < path.length - 2; i++) {\n    if (lineSegmentsIntersect(path[0], path[path.length - 1], path[i], path[i + 1])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getIntersectionPoint(p1, p2, q1, q2, delta) {\n  if (delta === void 0) {\n    delta = 0;\n  }\n  const a1 = p2[1] - p1[1];\n  const b1 = p1[0] - p2[0];\n  const c1 = a1 * p1[0] + b1 * p1[1];\n  const a2 = q2[1] - q1[1];\n  const b2 = q1[0] - q2[0];\n  const c2 = a2 * q1[0] + b2 * q1[1];\n  const det = a1 * b2 - a2 * b1;\n  if (!scalarsEqual(det, 0, delta)) {\n    return [(b2 * c1 - b1 * c2) / det, (a1 * c2 - a2 * c1) / det];\n  } else {\n    return [0, 0];\n  }\n}\n\n/**\n * Quickly decompose the Polygon into convex sub-polygons.\n * @param polygon the polygon to decompose\n * @param result\n * @param reflexVertices\n * @param steinerPoints\n * @param delta\n * @param maxlevel\n * @param level\n * @return the decomposed sub-polygons\n */\nfunction quickDecomp(polygon, result, reflexVertices, steinerPoints, delta, maxlevel, level) {\n  if (result === void 0) {\n    result = [];\n  }\n  if (reflexVertices === void 0) {\n    reflexVertices = [];\n  }\n  if (steinerPoints === void 0) {\n    steinerPoints = [];\n  }\n  if (delta === void 0) {\n    delta = 25;\n  }\n  if (maxlevel === void 0) {\n    maxlevel = 100;\n  }\n  if (level === void 0) {\n    level = 0;\n  }\n  // Points\n  let upperInt = [0, 0];\n  let lowerInt = [0, 0];\n  let p = [0, 0];\n\n  // scalars\n  let upperDist = 0;\n  let lowerDist = 0;\n  let d = 0;\n  let closestDist = 0;\n\n  // Integers\n  let upperIndex = 0;\n  let lowerIndex = 0;\n  let closestIndex = 0;\n\n  // polygons\n  const lowerPoly = [];\n  const upperPoly = [];\n  const poly = polygon;\n  const v = polygon;\n  if (v.length < 3) {\n    return result;\n  }\n  level++;\n  if (level > maxlevel) {\n    console.warn('quickDecomp: max level (' + maxlevel + ') reached.');\n    return result;\n  }\n  for (let i = 0; i < polygon.length; ++i) {\n    if (polygonIsReflex(poly, i)) {\n      reflexVertices.push(poly[i]);\n      upperDist = lowerDist = Number.MAX_VALUE;\n      for (let j = 0; j < polygon.length; ++j) {\n        if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j - 1))) {\n          // if line intersects with an edge\n          p = getIntersectionPoint(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j - 1)); // find the point of intersection\n          if (isRight(polygonAt(poly, i + 1), polygonAt(poly, i), p)) {\n            // make sure it's inside the poly\n            d = sqdist(poly[i], p);\n            if (d < lowerDist) {\n              // keep only the closest intersection\n              lowerDist = d;\n              lowerInt = p;\n              lowerIndex = j;\n            }\n          }\n        }\n        if (isLeft(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j + 1)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n          p = getIntersectionPoint(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j), polygonAt(poly, j + 1));\n          if (isLeft(polygonAt(poly, i - 1), polygonAt(poly, i), p)) {\n            d = sqdist(poly[i], p);\n            if (d < upperDist) {\n              upperDist = d;\n              upperInt = p;\n              upperIndex = j;\n            }\n          }\n        }\n      }\n\n      // if there are no vertices to connect to, choose a point in the middle\n      if (lowerIndex === (upperIndex + 1) % polygon.length) {\n        p[0] = (lowerInt[0] + upperInt[0]) / 2;\n        p[1] = (lowerInt[1] + upperInt[1]) / 2;\n        steinerPoints.push(p);\n        if (i < upperIndex) {\n          polygonAppend(lowerPoly, poly, i, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n          if (lowerIndex !== 0) {\n            polygonAppend(upperPoly, poly, lowerIndex, poly.length);\n          }\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            polygonAppend(lowerPoly, poly, i, poly.length);\n          }\n          polygonAppend(lowerPoly, poly, 0, upperIndex + 1);\n          lowerPoly.push(p);\n          upperPoly.push(p);\n          polygonAppend(upperPoly, poly, lowerIndex, i + 1);\n        }\n      } else {\n        // connect to the closest point within the triangle\n        if (lowerIndex > upperIndex) {\n          upperIndex += polygon.length;\n        }\n        closestDist = Number.MAX_VALUE;\n        if (upperIndex < lowerIndex) {\n          return result;\n        }\n        for (let j = lowerIndex; j <= upperIndex; ++j) {\n          if (isLeftOn(polygonAt(poly, i - 1), polygonAt(poly, i), polygonAt(poly, j)) && isRightOn(polygonAt(poly, i + 1), polygonAt(poly, i), polygonAt(poly, j))) {\n            d = sqdist(polygonAt(poly, i), polygonAt(poly, j));\n            if (d < closestDist && polygonCanSee2(poly, i, j)) {\n              closestDist = d;\n              closestIndex = j % polygon.length;\n            }\n          }\n        }\n        if (i < closestIndex) {\n          polygonAppend(lowerPoly, poly, i, closestIndex + 1);\n          if (closestIndex !== 0) {\n            polygonAppend(upperPoly, poly, closestIndex, v.length);\n          }\n          polygonAppend(upperPoly, poly, 0, i + 1);\n        } else {\n          if (i !== 0) {\n            polygonAppend(lowerPoly, poly, i, v.length);\n          }\n          polygonAppend(lowerPoly, poly, 0, closestIndex + 1);\n          polygonAppend(upperPoly, poly, closestIndex, i + 1);\n        }\n      }\n\n      // solve smallest poly first\n      if (lowerPoly.length < upperPoly.length) {\n        quickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        quickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      } else {\n        quickDecomp(upperPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n        quickDecomp(lowerPoly, result, reflexVertices, steinerPoints, delta, maxlevel, level);\n      }\n      return result;\n    }\n  }\n  result.push(polygon);\n  return result;\n}\n\n/**\n * Remove collinear points in the polygon.\n * @param thresholdAngle The threshold angle to use when determining whether two edges are collinear. Use zero for finest precision.\n * @return The number of points removed\n */\nfunction removeCollinearPoints(polygon, thresholdAngle) {\n  if (thresholdAngle === void 0) {\n    thresholdAngle = 0;\n  }\n  let num = 0;\n  for (let i = polygon.length - 1; polygon.length > 3 && i >= 0; --i) {\n    if (collinear(polygonAt(polygon, i - 1), polygonAt(polygon, i), polygonAt(polygon, i + 1), thresholdAngle)) {\n      // Remove the middle point\n      polygon.splice(i % polygon.length, 1);\n      num++;\n    }\n  }\n  return num;\n}\n\n/**\n * Check if two scalars are equal\n * @param a scalar a\n * @param b scalar b\n * @param precision the precision for the equality check\n * @return whether the two scalars are equal with the given precision\n */\nfunction scalarsEqual(a, b, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  precision = precision || 0;\n  return Math.abs(a - b) <= precision;\n}\n\n/**\n * Check if two points are equal\n * @param a point a\n * @param b point b\n * @param precision the precision for the equality check\n * @return if the two points are equal\n */\nfunction pointsEqual(a, b, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  return scalarsEqual(a[0], b[0], precision) && scalarsEqual(a[1], b[1], precision);\n}\n\n/**\n * Remove duplicate points in the polygon.\n * @param precision The threshold to use when determining whether two points are the same. Use zero for best precision.\n */\nfunction removeDuplicatePoints(polygon, precision) {\n  if (precision === void 0) {\n    precision = 0;\n  }\n  for (let i = polygon.length - 1; i >= 1; --i) {\n    const pi = polygon[i];\n    for (let j = i - 1; j >= 0; --j) {\n      if (pointsEqual(pi, polygon[j], precision)) {\n        polygon.splice(i, 1);\n        continue;\n      }\n    }\n  }\n}\n\nexport { decomp, isSimple, makeCCW, quickDecomp, removeCollinearPoints, removeDuplicatePoints };\n","import { Response, Circle as SATCircle, Polygon as SATPolygon, Vector as SATVector, } from \"sat\";\n// version 4.0.0 1=1 copy\nimport RBush from \"./external/rbush\";\nexport { isSimple, quickDecomp, } from \"poly-decomp-es\";\nexport { RBush, Response, SATCircle, SATPolygon, SATVector };\n/**\n * types\n */\nexport var BodyType;\n(function (BodyType) {\n    BodyType[\"Ellipse\"] = \"Ellipse\";\n    BodyType[\"Circle\"] = \"Circle\";\n    BodyType[\"Polygon\"] = \"Polygon\";\n    BodyType[\"Box\"] = \"Box\";\n    BodyType[\"Line\"] = \"Line\";\n    BodyType[\"Point\"] = \"Point\";\n})(BodyType || (BodyType = {}));\n/**\n * for groups\n */\nexport var BodyGroup;\n(function (BodyGroup) {\n    BodyGroup[BodyGroup[\"Ellipse\"] = 32] = \"Ellipse\";\n    BodyGroup[BodyGroup[\"Circle\"] = 16] = \"Circle\";\n    BodyGroup[BodyGroup[\"Polygon\"] = 8] = \"Polygon\";\n    BodyGroup[BodyGroup[\"Box\"] = 4] = \"Box\";\n    BodyGroup[BodyGroup[\"Line\"] = 2] = \"Line\";\n    BodyGroup[BodyGroup[\"Point\"] = 1] = \"Point\";\n})(BodyGroup || (BodyGroup = {}));\n","/* tslint:disable:one-variable-per-declaration */\n/**\n * 40-90% faster than built-in Array.forEach function.\n *\n * basic benchmark: https://jsbench.me/urle772xdn\n */\nexport const forEach = (array, callback) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n        callback(array[i], i);\n    }\n};\n/**\n * 20-90% faster than built-in Array.some function.\n *\n * basic benchmark: https://jsbench.me/l0le7bnnsq\n */\nexport const some = (array, callback) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n        if (callback(array[i], i)) {\n            return true;\n        }\n    }\n    return false;\n};\n/**\n * 20-40% faster than built-in Array.every function.\n *\n * basic benchmark: https://jsbench.me/unle7da29v\n */\nexport const every = (array, callback) => {\n    for (let i = 0, l = array.length; i < l; i++) {\n        if (!callback(array[i], i)) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * 20-60% faster than built-in Array.filter function.\n *\n * basic benchmark: https://jsbench.me/o1le77ev4l\n */\nexport const filter = (array, callback) => {\n    const output = [];\n    for (let i = 0, l = array.length; i < l; i++) {\n        const item = array[i];\n        if (callback(item, i)) {\n            output.push(item);\n        }\n    }\n    return output;\n};\n/**\n * 20-70% faster than built-in Array.map\n *\n * basic benchmark: https://jsbench.me/oyle77vbpc\n */\nexport const map = (array, callback) => {\n    const l = array.length;\n    const output = new Array(l);\n    for (let i = 0; i < l; i++) {\n        output[i] = callback(array[i], i);\n    }\n    return output;\n};\n","/* tslint:disable:trailing-whitespace */\n/* tslint:disable:cyclomatic-complexity */\nimport { pointInCircle, pointInPolygon as pointInConvexPolygon } from \"sat\";\nimport { BodyGroup } from \"./model\";\nimport { every, forEach, map, some } from \"./optimized\";\n/**\n * replace body with array of related convex polygons\n */\nexport function ensureConvex(body) {\n    if (body.isConvex || body.typeGroup !== BodyGroup.Polygon) {\n        return [body];\n    }\n    return body.convexPolygons;\n}\n/**\n * @param polygon\n * @param circle\n */\nexport function polygonInCircle(polygon, circle) {\n    return every(polygon.calcPoints, (p) => {\n        const point = {\n            x: p.x + polygon.pos.x,\n            y: p.y + polygon.pos.y,\n        };\n        return pointInCircle(point, circle);\n    });\n}\nexport function pointInPolygon(point, polygon) {\n    return some(ensureConvex(polygon), (convex) => pointInConvexPolygon(point, convex));\n}\nexport function polygonInPolygon(polygonA, polygonB) {\n    return every(polygonA.calcPoints, (point) => pointInPolygon({ x: point.x + polygonA.pos.x, y: point.y + polygonA.pos.y }, polygonB));\n}\n/**\n * https://stackoverflow.com/a/68197894/1749528\n *\n * @param point\n * @param circle\n */\nexport function pointOnCircle(point, circle) {\n    return ((point.x - circle.pos.x) * (point.x - circle.pos.x) +\n        (point.y - circle.pos.y) * (point.y - circle.pos.y) ===\n        circle.r * circle.r);\n}\n/**\n * https://stackoverflow.com/a/68197894/1749528\n *\n * @param circle1\n * @param circle2\n */\nexport function circleInCircle(circle1, circle2) {\n    const x1 = circle1.pos.x;\n    const y1 = circle1.pos.y;\n    const x2 = circle2.pos.x;\n    const y2 = circle2.pos.y;\n    const r1 = circle1.r;\n    const r2 = circle2.r;\n    const distSq = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    return distSq + r2 === r1 || distSq + r2 < r1;\n}\n/**\n * https://stackoverflow.com/a/68197894/1749528\n *\n * @param circle\n * @param polygon\n */\nexport function circleInPolygon(circle, polygon) {\n    // Circle with radius 0 isn't a circle\n    if (circle.r === 0) {\n        return false;\n    }\n    // If the center of the circle is not within the polygon,\n    // then the circle may overlap, but it'll never be \"contained\"\n    // so return false\n    if (!pointInPolygon(circle.pos, polygon)) {\n        return false;\n    }\n    // Necessary add polygon pos to points\n    const points = map(polygon.calcPoints, ({ x, y }) => ({\n        x: x + polygon.pos.x,\n        y: y + polygon.pos.y,\n    }));\n    // If the center of the circle is within the polygon,\n    // the circle is not outside of the polygon completely.\n    // so return false.\n    if (some(points, (point) => pointInCircle(point, circle))) {\n        return false;\n    }\n    // If any line-segment of the polygon intersects the circle,\n    // the circle is not \"contained\"\n    // so return false\n    if (some(points, (end, index) => {\n        const start = index\n            ? points[index - 1]\n            : points[points.length - 1];\n        return intersectLineCircle({ start, end }, circle).length > 0;\n    })) {\n        return false;\n    }\n    return true;\n}\n/**\n * https://stackoverflow.com/a/68197894/1749528\n *\n * @param circle\n * @param polygon\n */\nexport function circleOutsidePolygon(circle, polygon) {\n    // Circle with radius 0 isn't a circle\n    if (circle.r === 0) {\n        return false;\n    }\n    // If the center of the circle is within the polygon,\n    // the circle is not outside of the polygon completely.\n    // so return false.\n    if (pointInPolygon(circle.pos, polygon)) {\n        return false;\n    }\n    // Necessary add polygon pos to points\n    const points = map(polygon.calcPoints, ({ x, y }) => ({\n        x: x + polygon.pos.x,\n        y: y + polygon.pos.y,\n    }));\n    // If the center of the circle is within the polygon,\n    // the circle is not outside of the polygon completely.\n    // so return false.\n    if (some(points, (point) => pointInCircle(point, circle) || pointOnCircle(point, circle))) {\n        return false;\n    }\n    // If any line-segment of the polygon intersects the circle,\n    // the circle is not \"contained\"\n    // so return false\n    if (some(points, (end, index) => {\n        const start = index\n            ? points[index - 1]\n            : points[points.length - 1];\n        return intersectLineCircle({ start, end }, circle).length > 0;\n    })) {\n        return false;\n    }\n    return true;\n}\n/**\n * https://stackoverflow.com/a/37225895/1749528\n *\n * @param line\n * @param circle\n */\nexport function intersectLineCircle(line, { pos, r }) {\n    const v1 = { x: line.end.x - line.start.x, y: line.end.y - line.start.y };\n    const v2 = { x: line.start.x - pos.x, y: line.start.y - pos.y };\n    const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n    const c = (v1.x * v1.x + v1.y * v1.y) * 2;\n    const d = Math.sqrt(b * b - (v2.x * v2.x + v2.y * v2.y - r * r) * c * 2);\n    if (isNaN(d)) {\n        // no intercept\n        return [];\n    }\n    const u1 = (b - d) / c; // these represent the unit distance of point one and two on the line\n    const u2 = (b + d) / c;\n    const results = []; // return array\n    if (u1 <= 1 && u1 >= 0) {\n        // add point if on the line segment\n        results.push({ x: line.start.x + v1.x * u1, y: line.start.y + v1.y * u1 });\n    }\n    if (u2 <= 1 && u2 >= 0) {\n        // second add point if on the line segment\n        results.push({ x: line.start.x + v1.x * u2, y: line.start.y + v1.y * u2 });\n    }\n    return results;\n}\n/**\n * helper for intersectLineLineFast\n */\nfunction isTurn(point1, point2, point3) {\n    const A = (point3.x - point1.x) * (point2.y - point1.y);\n    const B = (point2.x - point1.x) * (point3.y - point1.y);\n    return A > B + Number.EPSILON ? 1 : A + Number.EPSILON < B ? -1 : 0;\n}\n/**\n * faster implementation of intersectLineLine\n * https://stackoverflow.com/a/16725715/1749528\n *\n * @param line1\n * @param line2\n */\nexport function intersectLineLineFast(line1, line2) {\n    return (isTurn(line1.start, line2.start, line2.end) !==\n        isTurn(line1.end, line2.start, line2.end) &&\n        isTurn(line1.start, line1.end, line2.start) !==\n            isTurn(line1.start, line1.end, line2.end));\n}\n/**\n * returns the point of intersection\n * https://stackoverflow.com/a/24392281/1749528\n *\n * @param line1\n * @param line2\n */\nexport function intersectLineLine(line1, line2) {\n    const dX = line1.end.x - line1.start.x;\n    const dY = line1.end.y - line1.start.y;\n    const determinant = dX * (line2.end.y - line2.start.y) - (line2.end.x - line2.start.x) * dY;\n    if (determinant === 0) {\n        return;\n    }\n    const lambda = ((line2.end.y - line2.start.y) * (line2.end.x - line1.start.x) +\n        (line2.start.x - line2.end.x) * (line2.end.y - line1.start.y)) /\n        determinant;\n    const gamma = ((line1.start.y - line1.end.y) * (line2.end.x - line1.start.x) +\n        dX * (line2.end.y - line1.start.y)) /\n        determinant;\n    // check if there is an intersection\n    if (!(lambda >= 0 && lambda <= 1) || !(gamma >= 0 && gamma <= 1)) {\n        return;\n    }\n    return { x: line1.start.x + lambda * dX, y: line1.start.y + lambda * dY };\n}\nexport function intersectLinePolygon(line, polygon) {\n    const results = [];\n    forEach(polygon.calcPoints, (to, index) => {\n        const from = index\n            ? polygon.calcPoints[index - 1]\n            : polygon.calcPoints[polygon.calcPoints.length - 1];\n        const side = {\n            start: { x: from.x + polygon.pos.x, y: from.y + polygon.pos.y },\n            end: { x: to.x + polygon.pos.x, y: to.y + polygon.pos.y },\n        };\n        const hit = intersectLineLine(line, side);\n        if (hit) {\n            results.push(hit);\n        }\n    });\n    return results;\n}\n/**\n * @param circle1\n * @param circle2\n */\nexport function intersectCircleCircle(circle1, circle2) {\n    const results = [];\n    const x1 = circle1.pos.x;\n    const y1 = circle1.pos.y;\n    const r1 = circle1.r;\n    const x2 = circle2.pos.x;\n    const y2 = circle2.pos.y;\n    const r2 = circle2.r;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const dist = Math.sqrt(dx * dx + dy * dy);\n    if (dist > r1 + r2 || dist < Math.abs(r1 - r2) || dist === 0) {\n        return results;\n    }\n    const a = (r1 * r1 - r2 * r2 + dist * dist) / (2 * dist);\n    const h = Math.sqrt(r1 * r1 - a * a);\n    const px = x1 + (dx * a) / dist;\n    const py = y1 + (dy * a) / dist;\n    const intersection1 = {\n        x: px + (h * dy) / dist,\n        y: py - (h * dx) / dist,\n    };\n    results.push(intersection1);\n    const intersection2 = {\n        x: px - (h * dy) / dist,\n        y: py + (h * dx) / dist,\n    };\n    results.push(intersection2);\n    return results;\n}\n","/* tslint:disable:cyclomatic-complexity */\nimport { testCircleCircle, testCirclePolygon, testPolygonCircle, testPolygonPolygon, } from \"sat\";\nimport { circleInCircle, circleInPolygon, polygonInCircle, polygonInPolygon, } from \"./intersect\";\nimport { BodyGroup, BodyType, Response, SATVector, } from \"./model\";\nimport { forEach, map } from \"./optimized\";\n/* helpers for faster getSATTest() and checkAInB() */\nconst testMap = {\n    satCircleCircle: testCircleCircle,\n    satCirclePolygon: testCirclePolygon,\n    satPolygonCircle: testPolygonCircle,\n    satPolygonPolygon: testPolygonPolygon,\n    inCircleCircle: circleInCircle,\n    inCirclePolygon: circleInPolygon,\n    inPolygonCircle: polygonInCircle,\n    inPolygonPolygon: polygonInPolygon,\n};\nfunction createArray(bodyType, testType) {\n    const arrayResult = [];\n    const bodyGroups = Object.values(BodyGroup).filter((value) => typeof value === \"number\");\n    forEach(bodyGroups, (bodyGroup) => {\n        arrayResult[bodyGroup] = (bodyGroup === BodyGroup.Circle\n            ? testMap[`${testType}${bodyType}Circle`]\n            : testMap[`${testType}${bodyType}Polygon`]);\n    });\n    return arrayResult;\n}\nconst circleSATFunctions = createArray(BodyType.Circle, \"sat\");\nconst circleInFunctions = createArray(BodyType.Circle, \"in\");\nconst polygonSATFunctions = createArray(BodyType.Polygon, \"sat\");\nconst polygonInFunctions = createArray(BodyType.Polygon, \"in\");\nexport const DEG2RAD = Math.PI / 180;\nexport const RAD2DEG = 180 / Math.PI;\n/**\n * convert from degrees to radians\n */\nexport function deg2rad(degrees) {\n    return degrees * DEG2RAD;\n}\n/**\n * convert from radians to degrees\n */\nexport function rad2deg(radians) {\n    return radians * RAD2DEG;\n}\n/**\n * creates ellipse-shaped polygon based on params\n */\nexport function createEllipse(radiusX, radiusY = radiusX, step = 1) {\n    const steps = Math.PI * Math.hypot(radiusX, radiusY) * 2;\n    const length = Math.max(8, Math.ceil(steps / Math.max(1, step)));\n    const ellipse = [];\n    for (let index = 0; index < length; index++) {\n        const value = (index / length) * 2 * Math.PI;\n        const x = Math.cos(value) * radiusX;\n        const y = Math.sin(value) * radiusY;\n        ellipse.push(new SATVector(x, y));\n    }\n    return ellipse;\n}\n/**\n * creates box shaped polygon points\n */\nexport function createBox(width, height) {\n    return [\n        new SATVector(0, 0),\n        new SATVector(width, 0),\n        new SATVector(width, height),\n        new SATVector(0, height),\n    ];\n}\n/**\n * ensure SATVector type point result\n */\nexport function ensureVectorPoint(point = {}) {\n    return point instanceof SATVector\n        ? point\n        : new SATVector(point.x || 0, point.y || 0);\n}\n/**\n * ensure Vector points (for polygon) in counter-clockwise order\n */\nexport function ensurePolygonPoints(points = []) {\n    const polygonPoints = map(points, ensureVectorPoint);\n    return clockwise(polygonPoints) ? polygonPoints.reverse() : polygonPoints;\n}\n/**\n * get distance between two Vector points\n */\nexport function distance(bodyA, bodyB) {\n    const xDiff = bodyA.x - bodyB.x;\n    const yDiff = bodyA.y - bodyB.y;\n    return Math.hypot(xDiff, yDiff);\n}\n/**\n * check [is clockwise] direction of polygon\n */\nexport function clockwise(points) {\n    const length = points.length;\n    let sum = 0;\n    forEach(points, (v1, index) => {\n        const v2 = points[(index + 1) % length];\n        sum += (v2.x - v1.x) * (v2.y + v1.y);\n    });\n    return sum > 0;\n}\n/**\n * used for all types of bodies in constructor\n */\nexport function extendBody(body, options = {}) {\n    body.isStatic = !!options.isStatic;\n    body.isTrigger = !!options.isTrigger;\n    body.padding = options.padding || 0;\n    // Default value should be reflected in documentation of `BodyOptions.group`\n    body.group = options.group ?? 0x7fffffff;\n    if (\"userData\" in options) {\n        body.userData = options.userData;\n    }\n    if (options.isCentered && body.typeGroup !== BodyGroup.Circle) {\n        body.isCentered = true;\n    }\n    if (options.angle) {\n        body.setAngle(options.angle);\n    }\n}\n/**\n * check if body moved outside of its padding\n */\nexport function bodyMoved(body) {\n    const { bbox, minX, minY, maxX, maxY } = body;\n    return (bbox.minX < minX || bbox.minY < minY || bbox.maxX > maxX || bbox.maxY > maxY);\n}\n/**\n * returns true if two boxes not intersect\n */\nexport function notIntersectAABB(bodyA, bodyB) {\n    return (bodyB.minX > bodyA.maxX ||\n        bodyB.minY > bodyA.maxY ||\n        bodyB.maxX < bodyA.minX ||\n        bodyB.maxY < bodyA.minY);\n}\n/**\n * checks if two boxes intersect\n */\nexport function intersectAABB(bodyA, bodyB) {\n    return !notIntersectAABB(bodyA, bodyB);\n}\n/**\n * checks if two bodies can interact (for collision filtering)\n *\n * Based on {@link https://box2d.org/documentation/md_simulation.html#filtering Box2D}\n * ({@link https://aurelienribon.wordpress.com/2011/07/01/box2d-tutorial-collision-filtering/ tutorial})\n *\n * @param bodyA\n * @param bodyB\n *\n * @example\n * const body1 = { group: 0b00000000_00000000_00000001_00000000 }\n * const body2 = { group: 0b11111111_11111111_00000011_00000000 }\n * const body3 = { group: 0b00000010_00000000_00000100_00000000 }\n *\n * // Body 1 has the first custom group but cannot interact with any other groups\n * // except itself because the first 16 bits are all zeros, only bodies with an\n * // identical value can interact with it.\n * canInteract(body1, body1) // returns true (identical groups can always interact)\n * canInteract(body1, body2) // returns false\n * canInteract(body1, body3) // returns false\n *\n * // Body 2 has the first and second group and can interact with all other\n * // groups, but only if that body also can interact with is custom group.\n * canInteract(body2, body1) // returns false (body1 cannot interact with others)\n * canInteract(body2, body2) // returns true (identical groups can always interact)\n * canInteract(body2, body3) // returns true\n *\n * // Body 3 has the third group but can interact with the second group.\n * // This means that Body 2 and Body 3 can interact with each other but no other\n * // body can interact with Body 1 because it doesn't allow interactions with\n * // any other custom group.\n * canInteract(body3, body1) // returns false (body1 cannot interact with others)\n * canInteract(body3, body2) // returns true\n * canInteract(body3, body3) // returns true (identical groups can always interact)\n */\nexport function canInteract({ group: groupA }, { group: groupB }) {\n    const categoryA = groupA >> 16;\n    const categoryB = groupB >> 16;\n    const maskA = groupA & 0xffff;\n    const maskB = groupB & 0xffff;\n    return (categoryA & maskB) !== 0 && (categoryB & maskA) !== 0; // Box2D rules\n}\n/**\n * checks if body a is in body b\n */\nexport function checkAInB(bodyA, bodyB) {\n    const check = bodyA.typeGroup === BodyGroup.Circle\n        ? circleInFunctions\n        : polygonInFunctions;\n    return check[bodyB.typeGroup](bodyA, bodyB);\n}\n/**\n * clone sat vector points array into vector points array\n */\nexport function clonePointsArray(points) {\n    return map(points, ({ x, y }) => ({ x, y }));\n}\n/**\n * change format from SAT.js to poly-decomp\n *\n * @param position\n */\nexport function mapVectorToArray({ x, y } = { x: 0, y: 0 }) {\n    return [x, y];\n}\n/**\n * change format from poly-decomp to SAT.js\n *\n * @param positionAsArray\n */\nexport function mapArrayToVector([x, y] = [0, 0]) {\n    return { x, y };\n}\n/**\n * given 2 bodies calculate vector of bounce assuming equal mass and they are circles\n */\nexport function getBounceDirection(body, collider) {\n    const v2 = new SATVector(collider.x - body.x, collider.y - body.y);\n    const v1 = new SATVector(body.x - collider.x, body.y - collider.y);\n    const len = v1.dot(v2.normalize()) * 2;\n    return new SATVector(v2.x * len - v1.x, v2.y * len - v1.y).normalize();\n}\n/**\n * returns correct sat.js testing function based on body types\n */\nexport function getSATTest(bodyA, bodyB) {\n    const check = bodyA.typeGroup === BodyGroup.Circle\n        ? circleSATFunctions\n        : polygonSATFunctions;\n    return check[bodyB.typeGroup];\n}\n/**\n * draws dashed line on canvas context\n */\nexport function dashLineTo(context, fromX, fromY, toX, toY, dash = 2, gap = 4) {\n    const xDiff = toX - fromX;\n    const yDiff = toY - fromY;\n    const arc = Math.atan2(yDiff, xDiff);\n    const offsetX = Math.cos(arc);\n    const offsetY = Math.sin(arc);\n    let posX = fromX;\n    let posY = fromY;\n    let dist = Math.hypot(xDiff, yDiff);\n    while (dist > 0) {\n        const step = Math.min(dist, dash);\n        context.moveTo(posX, posY);\n        context.lineTo(posX + offsetX * step, posY + offsetY * step);\n        posX += offsetX * (dash + gap);\n        posY += offsetY * (dash + gap);\n        dist -= dash + gap;\n    }\n}\n/**\n * draw polygon\n *\n * @param context\n * @param polygon\n * @param isTrigger\n */\nexport function drawPolygon(context, { pos, calcPoints, }, isTrigger = false) {\n    const lastPoint = calcPoints[calcPoints.length - 1];\n    const fromX = pos.x + lastPoint.x;\n    const fromY = pos.y + lastPoint.y;\n    if (calcPoints.length === 1) {\n        context.arc(fromX, fromY, 1, 0, Math.PI * 2);\n    }\n    else {\n        context.moveTo(fromX, fromY);\n    }\n    forEach(calcPoints, (point, index) => {\n        const toX = pos.x + point.x;\n        const toY = pos.y + point.y;\n        if (isTrigger) {\n            const prev = calcPoints[index - 1] || lastPoint;\n            dashLineTo(context, pos.x + prev.x, pos.y + prev.y, toX, toY);\n        }\n        else {\n            context.lineTo(toX, toY);\n        }\n    });\n}\n/**\n * draw body bounding body box\n */\nexport function drawBVH(context, body, isTrigger = true) {\n    drawPolygon(context, {\n        pos: { x: body.minX, y: body.minY },\n        calcPoints: createBox(body.maxX - body.minX, body.maxY - body.minY),\n    }, isTrigger);\n}\n/**\n * clone response object returning new response with previous ones values\n */\nexport function cloneResponse(response) {\n    const clone = new Response();\n    const { a, b, overlap, overlapN, overlapV, aInB, bInA } = response;\n    clone.a = a;\n    clone.b = b;\n    clone.overlap = overlap;\n    clone.overlapN = overlapN.clone();\n    clone.overlapV = overlapV.clone();\n    clone.aInB = aInB;\n    clone.bInA = bInA;\n    return clone;\n}\n/**\n * dummy fn used as default, for optimization\n */\nexport function returnTrue() {\n    return true;\n}\n/**\n * for groups\n */\nexport function getGroup(group) {\n    return Math.max(0, Math.min(group, 0x7fffffff));\n}\n/**\n * binary string to decimal number\n */\nexport function bin2dec(binary) {\n    return Number(`0b${binary}`.replace(/\\s/g, \"\"));\n}\n/**\n * helper for groupBits()\n *\n * @param input - number or binary string\n */\nexport function ensureNumber(input) {\n    return typeof input === \"number\" ? input : bin2dec(input);\n}\n/**\n * create group bits from category and mask\n *\n * @param category - category bits\n * @param mask - mask bits (default: category)\n */\nexport function groupBits(category, mask = category) {\n    return (ensureNumber(category) << 16) | ensureNumber(mask);\n}\nexport function move(body, speed = 1, updateNow = true) {\n    if (!speed) {\n        return;\n    }\n    const moveX = Math.cos(body.angle) * speed;\n    const moveY = Math.sin(body.angle) * speed;\n    body.setPosition(body.x + moveX, body.y + moveY, updateNow);\n}\n","import { BodyGroup, BodyType, SATCircle, } from \"../model\";\nimport { dashLineTo, drawBVH, ensureVectorPoint, extendBody, getGroup, move, } from \"../utils\";\n/**\n * collider - circle\n */\nexport class Circle extends SATCircle {\n    /**\n     * collider - circle\n     */\n    constructor(position, radius, options) {\n        super(ensureVectorPoint(position), radius);\n        /**\n         * offset copy without angle applied\n         */\n        this.offsetCopy = { x: 0, y: 0 };\n        /**\n         * was the polygon modified and needs update in the next checkCollision\n         */\n        this.dirty = false;\n        /*\n         * circles are convex\n         */\n        this.isConvex = true;\n        /**\n         * circle type\n         */\n        this.type = BodyType.Circle;\n        /**\n         * faster than type\n         */\n        this.typeGroup = BodyGroup.Circle;\n        /**\n         * always centered\n         */\n        this.isCentered = true;\n        extendBody(this, options);\n        this.unscaledRadius = radius;\n    }\n    /**\n     * get this.pos.x\n     */\n    get x() {\n        return this.pos.x;\n    }\n    /**\n     * updating this.pos.x by this.x = x updates AABB\n     */\n    set x(x) {\n        this.pos.x = x;\n        this.markAsDirty();\n    }\n    /**\n     * get this.pos.y\n     */\n    get y() {\n        return this.pos.y;\n    }\n    /**\n     * updating this.pos.y by this.y = y updates AABB\n     */\n    set y(y) {\n        this.pos.y = y;\n        this.markAsDirty();\n    }\n    /**\n     * allow get scale\n     */\n    get scale() {\n        return this.r / this.unscaledRadius;\n    }\n    /**\n     * shorthand for setScale()\n     */\n    set scale(scale) {\n        this.setScale(scale);\n    }\n    /**\n     * scaleX = scale in case of Circles\n     */\n    get scaleX() {\n        return this.scale;\n    }\n    /**\n     * scaleY = scale in case of Circles\n     */\n    get scaleY() {\n        return this.scale;\n    }\n    // Don't overwrite docs from BodyProps\n    get group() {\n        return this._group;\n    }\n    // Don't overwrite docs from BodyProps\n    set group(group) {\n        this._group = getGroup(group);\n    }\n    /**\n     * update position BY MOVING FORWARD IN ANGLE DIRECTION\n     */\n    move(speed = 1, updateNow = true) {\n        move(this, speed, updateNow);\n        return this;\n    }\n    /**\n     * update position BY TELEPORTING\n     */\n    setPosition(x, y, updateNow = true) {\n        this.pos.x = x;\n        this.pos.y = y;\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    /**\n     * update scale\n     */\n    setScale(scaleX, _scaleY = scaleX, updateNow = true) {\n        this.r = this.unscaledRadius * Math.abs(scaleX);\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    /**\n     * set rotation\n     */\n    setAngle(angle, updateNow = true) {\n        this.angle = angle;\n        const { x, y } = this.getOffsetWithAngle();\n        this.offset.x = x;\n        this.offset.y = y;\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    /**\n     * set offset from center\n     */\n    setOffset(offset, updateNow = true) {\n        this.offsetCopy.x = offset.x;\n        this.offsetCopy.y = offset.y;\n        const { x, y } = this.getOffsetWithAngle();\n        this.offset.x = x;\n        this.offset.y = y;\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    /**\n     * get body bounding box, without padding\n     */\n    getAABBAsBBox() {\n        const x = this.pos.x + this.offset.x;\n        const y = this.pos.y + this.offset.y;\n        return {\n            minX: x - this.r,\n            maxX: x + this.r,\n            minY: y - this.r,\n            maxY: y + this.r,\n        };\n    }\n    /**\n     * Draws collider on a CanvasRenderingContext2D's current path\n     */\n    draw(context) {\n        const x = this.pos.x + this.offset.x;\n        const y = this.pos.y + this.offset.y;\n        const r = Math.abs(this.r);\n        if (this.isTrigger) {\n            const max = Math.max(8, this.r);\n            for (let i = 0; i < max; i++) {\n                const arc = (i / max) * 2 * Math.PI;\n                const arcPrev = ((i - 1) / max) * 2 * Math.PI;\n                const fromX = x + Math.cos(arcPrev) * this.r;\n                const fromY = y + Math.sin(arcPrev) * this.r;\n                const toX = x + Math.cos(arc) * this.r;\n                const toY = y + Math.sin(arc) * this.r;\n                dashLineTo(context, fromX, fromY, toX, toY);\n            }\n        }\n        else {\n            context.moveTo(x + r, y);\n            context.arc(x, y, r, 0, Math.PI * 2);\n        }\n    }\n    /**\n     * Draws Bounding Box on canvas context\n     */\n    drawBVH(context) {\n        drawBVH(context, this);\n    }\n    /**\n     * inner function for after position change update aabb in system\n     */\n    updateBody(updateNow = this.dirty) {\n        if (updateNow) {\n            this.system?.insert(this);\n            this.dirty = false;\n        }\n    }\n    /**\n     * update instantly or mark as dirty\n     */\n    markAsDirty(updateNow = false) {\n        if (updateNow) {\n            this.updateBody(true);\n        }\n        else {\n            this.dirty = true;\n        }\n    }\n    /**\n     * internal for getting offset with applied angle\n     */\n    getOffsetWithAngle() {\n        if ((!this.offsetCopy.x && !this.offsetCopy.y) || !this.angle) {\n            return this.offsetCopy;\n        }\n        const sin = Math.sin(this.angle);\n        const cos = Math.cos(this.angle);\n        const x = this.offsetCopy.x * cos - this.offsetCopy.y * sin;\n        const y = this.offsetCopy.x * sin + this.offsetCopy.y * cos;\n        return { x, y };\n    }\n}\n","import { BodyGroup, BodyType, SATPolygon, SATVector, isSimple, quickDecomp, } from \"../model\";\nimport { forEach, map } from \"../optimized\";\nimport { clonePointsArray, drawBVH, drawPolygon, ensurePolygonPoints, ensureVectorPoint, extendBody, getGroup, mapArrayToVector, mapVectorToArray, move, } from \"../utils\";\n/**\n * collider - polygon\n */\nexport class Polygon extends SATPolygon {\n    /**\n     * collider - polygon\n     */\n    constructor(position, points, options) {\n        super(ensureVectorPoint(position), ensurePolygonPoints(points));\n        /**\n         * was the polygon modified and needs update in the next checkCollision\n         */\n        this.dirty = false;\n        /**\n         * type of body\n         */\n        this.type = BodyType.Polygon;\n        /**\n         * faster than type\n         */\n        this.typeGroup = BodyGroup.Polygon;\n        /**\n         * is body centered\n         */\n        this.centered = false;\n        /**\n         * scale Vector of body\n         */\n        this.scaleVector = { x: 1, y: 1 };\n        if (!points.length) {\n            throw new Error(\"No points in polygon\");\n        }\n        extendBody(this, options);\n    }\n    /**\n     * flag to set is polygon centered\n     */\n    set isCentered(center) {\n        if (this.centered === center)\n            return;\n        let centroid;\n        this.runWithoutRotation(() => {\n            centroid = this.getCentroid();\n        });\n        const offsetX = center ? -centroid.x : -this.points[0].x;\n        const offsetY = center ? -centroid.y : -this.points[0].y;\n        this.setPoints(map(this.points, ({ x, y }) => new SATVector(x + offsetX, y + offsetY)));\n        this.centered = center;\n    }\n    /**\n     * is polygon centered?\n     */\n    get isCentered() {\n        return this.centered;\n    }\n    get x() {\n        return this.pos.x;\n    }\n    /**\n     * updating this.pos.x by this.x = x updates AABB\n     */\n    set x(x) {\n        this.pos.x = x;\n        this.markAsDirty();\n    }\n    get y() {\n        return this.pos.y;\n    }\n    /**\n     * updating this.pos.y by this.y = y updates AABB\n     */\n    set y(y) {\n        this.pos.y = y;\n        this.markAsDirty();\n    }\n    /**\n     * allow exact getting of scale x - use setScale(x, y) to set\n     */\n    get scaleX() {\n        return this.scaleVector.x;\n    }\n    /**\n     * allow exact getting of scale y - use setScale(x, y) to set\n     */\n    get scaleY() {\n        return this.scaleVector.y;\n    }\n    /**\n     * allow approx getting of scale\n     */\n    get scale() {\n        return (this.scaleVector.x + this.scaleVector.y) / 2;\n    }\n    /**\n     * allow easier setting of scale\n     */\n    set scale(scale) {\n        this.setScale(scale);\n    }\n    // Don't overwrite docs from BodyProps\n    get group() {\n        return this._group;\n    }\n    // Don't overwrite docs from BodyProps\n    set group(group) {\n        this._group = getGroup(group);\n    }\n    /**\n     * update position BY MOVING FORWARD IN ANGLE DIRECTION\n     */\n    move(speed = 1, updateNow = true) {\n        move(this, speed, updateNow);\n        return this;\n    }\n    /**\n     * update position BY TELEPORTING\n     */\n    setPosition(x, y, updateNow = true) {\n        this.pos.x = x;\n        this.pos.y = y;\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    /**\n     * update scale\n     */\n    setScale(x, y = x, updateNow = true) {\n        this.scaleVector.x = Math.abs(x);\n        this.scaleVector.y = Math.abs(y);\n        super.setPoints(map(this.points, (_point, index) => new SATVector(this.pointsBackup[index].x * this.scaleVector.x, this.pointsBackup[index].y * this.scaleVector.y)));\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    setAngle(angle, updateNow = true) {\n        super.setAngle(angle);\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    setOffset(offset, updateNow = true) {\n        super.setOffset(offset);\n        this.markAsDirty(updateNow);\n        return this;\n    }\n    /**\n     * get body bounding box, without padding\n     */\n    getAABBAsBBox() {\n        const { pos, w, h } = this.getAABBAsBox();\n        return {\n            minX: pos.x,\n            minY: pos.y,\n            maxX: pos.x + w,\n            maxY: pos.y + h,\n        };\n    }\n    /**\n     * Get edge line by index\n     */\n    getEdge(index) {\n        const { x, y } = this.calcPoints[index];\n        const next = this.calcPoints[(index + 1) % this.calcPoints.length];\n        const start = {\n            x: this.x + x,\n            y: this.y + y,\n        };\n        const end = {\n            x: this.x + next.x,\n            y: this.y + next.y,\n        };\n        return { start, end };\n    }\n    /**\n     * Draws exact collider on canvas context\n     */\n    draw(context) {\n        drawPolygon(context, this, this.isTrigger);\n    }\n    /**\n     * Draws Bounding Box on canvas context\n     */\n    drawBVH(context) {\n        drawBVH(context, this);\n    }\n    /**\n     * sets polygon points to new array of vectors\n     */\n    setPoints(points) {\n        super.setPoints(points);\n        this.updateIsConvex();\n        this.pointsBackup = clonePointsArray(points);\n        return this;\n    }\n    /**\n     * translates polygon points in x, y direction\n     */\n    translate(x, y) {\n        super.translate(x, y);\n        this.pointsBackup = clonePointsArray(this.points);\n        return this;\n    }\n    /**\n     * rotates polygon points by angle, in radians\n     */\n    rotate(angle) {\n        super.rotate(angle);\n        this.pointsBackup = clonePointsArray(this.points);\n        return this;\n    }\n    /**\n     * if true, polygon is not an invalid, self-crossing polygon\n     */\n    isSimple() {\n        return isSimple(map(this.calcPoints, mapVectorToArray));\n    }\n    /**\n     * inner function for after position change update aabb in system and convex inner polygons\n     */\n    updateBody(updateNow = this.dirty) {\n        if (updateNow) {\n            this.updateConvexPolygonPositions();\n            this.system?.insert(this);\n            this.dirty = false;\n        }\n    }\n    /**\n     * used to do stuff with temporarily disabled rotation\n     */\n    runWithoutRotation(callback) {\n        const angle = this.angle;\n        this.setAngle(0, false);\n        callback();\n        this.setAngle(angle, false);\n    }\n    /**\n     * update instantly or mark as dirty\n     */\n    markAsDirty(updateNow = false) {\n        if (updateNow) {\n            this.updateBody(true);\n        }\n        else {\n            this.dirty = true;\n        }\n    }\n    /**\n     * update the position of the decomposed convex polygons (if any), called\n     * after the position of the body has changed\n     */\n    updateConvexPolygonPositions() {\n        if (this.isConvex || !this.convexPolygons) {\n            return;\n        }\n        forEach(this.convexPolygons, (polygon) => {\n            polygon.pos.x = this.pos.x;\n            polygon.pos.y = this.pos.y;\n            if (polygon.angle !== this.angle) {\n                // Must use setAngle to recalculate the points of the Polygon\n                polygon.setAngle(this.angle);\n            }\n        });\n    }\n    /**\n     * returns body split into convex polygons, or empty array for convex bodies\n     */\n    getConvex() {\n        if ((this.typeGroup && this.typeGroup !== BodyGroup.Polygon) ||\n            this.points.length < 4) {\n            return [];\n        }\n        const points = map(this.calcPoints, mapVectorToArray);\n        return quickDecomp(points);\n    }\n    /**\n     * updates convex polygons cache in body\n     */\n    updateConvexPolygons(convex = this.getConvex()) {\n        if (this.isConvex) {\n            return;\n        }\n        if (!this.convexPolygons) {\n            this.convexPolygons = [];\n        }\n        forEach(convex, (points, index) => {\n            // lazy create\n            if (!this.convexPolygons[index]) {\n                this.convexPolygons[index] = new SATPolygon();\n            }\n            this.convexPolygons[index].pos.x = this.pos.x;\n            this.convexPolygons[index].pos.y = this.pos.y;\n            this.convexPolygons[index].angle = this.angle;\n            this.convexPolygons[index].setPoints(ensurePolygonPoints(map(points, mapArrayToVector)));\n        });\n        // trim array length\n        this.convexPolygons.length = convex.length;\n    }\n    /**\n     * after points update set is convex\n     */\n    updateIsConvex() {\n        // all other types other than polygon are always convex\n        const convex = this.getConvex();\n        // everything with empty array or one element array\n        this.isConvex = convex.length <= 1;\n        this.updateConvexPolygons(convex);\n    }\n}\n","import { BodyGroup, BodyType } from \"../model\";\nimport { createEllipse } from \"../utils\";\nimport { Polygon } from \"./polygon\";\n/**\n * collider - ellipse\n */\nexport class Ellipse extends Polygon {\n    /**\n     * collider - ellipse\n     */\n    constructor(position, radiusX, radiusY = radiusX, step = (radiusX + radiusY) / Math.PI, options) {\n        super(position, createEllipse(radiusX, radiusY, step), options);\n        /**\n         * ellipse type\n         */\n        this.type = BodyType.Ellipse;\n        /**\n         * faster than type\n         */\n        this.typeGroup = BodyGroup.Ellipse;\n        /**\n         * ellipses are convex\n         */\n        this.isConvex = true;\n        this._radiusX = radiusX;\n        this._radiusY = radiusY;\n        this._step = step;\n    }\n    /**\n     * flag to set is body centered\n     */\n    set isCentered(_isCentered) { }\n    /**\n     * is body centered?\n     */\n    get isCentered() {\n        return true;\n    }\n    /**\n     * get ellipse step number\n     */\n    get step() {\n        return this._step;\n    }\n    /**\n     * set ellipse step number\n     */\n    set step(step) {\n        this._step = step;\n        this.setPoints(createEllipse(this._radiusX, this._radiusY, this._step));\n    }\n    /**\n     * get ellipse radiusX\n     */\n    get radiusX() {\n        return this._radiusX;\n    }\n    /**\n     * set ellipse radiusX, update points\n     */\n    set radiusX(radiusX) {\n        this._radiusX = radiusX;\n        this.setPoints(createEllipse(this._radiusX, this._radiusY, this._step));\n    }\n    /**\n     * get ellipse radiusY\n     */\n    get radiusY() {\n        return this._radiusY;\n    }\n    /**\n     * set ellipse radiusY, update points\n     */\n    set radiusY(radiusY) {\n        this._radiusY = radiusY;\n        this.setPoints(createEllipse(this._radiusX, this._radiusY, this._step));\n    }\n    /**\n     * do not attempt to use Polygon.center()\n     */\n    center() {\n        return;\n    }\n    /**\n     * do not attempt to use Polygon.updateIsConvex()\n     */\n    updateIsConvex() {\n        return;\n    }\n}\n","import { BodyGroup, BodyType } from \"../model\";\nimport { createBox } from \"../utils\";\nimport { Polygon } from \"./polygon\";\n/**\n * collider - box\n */\nexport class Box extends Polygon {\n    /**\n     * collider - box\n     */\n    constructor(position, width, height, options) {\n        super(position, createBox(width, height), options);\n        /**\n         * type of body\n         */\n        this.type = BodyType.Box;\n        /**\n         * faster than type\n         */\n        this.typeGroup = BodyGroup.Box;\n        /**\n         * boxes are convex\n         */\n        this.isConvex = true;\n        this._width = width;\n        this._height = height;\n    }\n    /**\n     * get box width\n     */\n    get width() {\n        return this._width;\n    }\n    /**\n     * set box width, update points\n     */\n    set width(width) {\n        this._width = width;\n        this.afterUpdateSize();\n    }\n    /**\n     * get box height\n     */\n    get height() {\n        return this._height;\n    }\n    /**\n     * set box height, update points\n     */\n    set height(height) {\n        this._height = height;\n        this.afterUpdateSize();\n    }\n    /**\n     * after setting width/height update translate\n     * see https://github.com/Prozi/detect-collisions/issues/70\n     */\n    afterUpdateSize() {\n        this.setPoints(createBox(this._width, this._height));\n    }\n    /**\n     * do not attempt to use Polygon.updateIsConvex()\n     */\n    updateIsConvex() {\n        return;\n    }\n}\n","import { BodyGroup, BodyType } from \"../model\";\nimport { ensureVectorPoint } from \"../utils\";\nimport { Box } from \"./box\";\n/**\n * collider - point (very tiny box)\n */\nexport class Point extends Box {\n    /**\n     * collider - point (very tiny box)\n     */\n    constructor(position, options) {\n        super(ensureVectorPoint(position), 0.001, 0.001, options);\n        /**\n         * point type\n         */\n        this.type = BodyType.Point;\n        /**\n         * faster than type\n         */\n        this.typeGroup = BodyGroup.Point;\n    }\n}\n","import { BodyGroup, BodyType, SATVector } from \"../model\";\nimport { Polygon } from \"./polygon\";\n/**\n * collider - line\n */\nexport class Line extends Polygon {\n    /**\n     * collider - line from start to end\n     */\n    constructor(start, end, options) {\n        super(start, [\n            { x: 0, y: 0 },\n            { x: end.x - start.x, y: end.y - start.y },\n        ], options);\n        /**\n         * line type\n         */\n        this.type = BodyType.Line;\n        /**\n         * faster than type\n         */\n        this.typeGroup = BodyGroup.Line;\n        /**\n         * line is convex\n         */\n        this.isConvex = true;\n        if (this.calcPoints.length === 1 || !end) {\n            console.error({ start, end });\n            throw new Error(\"No end point for line provided\");\n        }\n    }\n    get start() {\n        return {\n            x: this.x + this.calcPoints[0].x,\n            y: this.y + this.calcPoints[0].y,\n        };\n    }\n    /**\n     * @param position\n     */\n    set start({ x, y }) {\n        this.x = x;\n        this.y = y;\n    }\n    get end() {\n        return {\n            x: this.x + this.calcPoints[1].x,\n            y: this.y + this.calcPoints[1].y,\n        };\n    }\n    /**\n     * @param position\n     */\n    set end({ x, y }) {\n        this.points[1].x = x - this.start.x;\n        this.points[1].y = y - this.start.y;\n        this.setPoints(this.points);\n    }\n    getCentroid() {\n        return new SATVector((this.end.x - this.start.x) / 2, (this.end.y - this.start.y) / 2);\n    }\n    /**\n     * do not attempt to use Polygon.updateIsConvex()\n     */\n    updateIsConvex() {\n        return;\n    }\n}\n","import { RBush, } from \"./model\";\nimport { filter, forEach } from \"./optimized\";\nimport { bodyMoved, drawBVH } from \"./utils\";\nimport { Box } from \"./bodies/box\";\nimport { Circle } from \"./bodies/circle\";\nimport { Ellipse } from \"./bodies/ellipse\";\nimport { Line } from \"./bodies/line\";\nimport { Point } from \"./bodies/point\";\nimport { Polygon } from \"./bodies/polygon\";\n/**\n * very base collision system (create, insert, update, draw, remove)\n */\nexport class BaseSystem extends RBush {\n    /**\n     * create point at position with options and add to system\n     */\n    createPoint(position, options, Class) {\n        const PointClass = Class || Point;\n        const point = new PointClass(position, options);\n        this.insert(point);\n        return point;\n    }\n    /**\n     * create line at position with options and add to system\n     */\n    createLine(start, end, options, Class) {\n        const LineClass = Class || Line;\n        const line = new LineClass(start, end, options);\n        this.insert(line);\n        return line;\n    }\n    /**\n     * create circle at position with options and add to system\n     */\n    createCircle(position, radius, options, Class) {\n        const CircleClass = Class || Circle;\n        const circle = new CircleClass(position, radius, options);\n        this.insert(circle);\n        return circle;\n    }\n    /**\n     * create box at position with options and add to system\n     */\n    createBox(position, width, height, options, Class) {\n        const BoxClass = Class || Box;\n        const box = new BoxClass(position, width, height, options);\n        this.insert(box);\n        return box;\n    }\n    /**\n     * create ellipse at position with options and add to system\n     */\n    createEllipse(position, radiusX, radiusY = radiusX, step, options, Class) {\n        const EllipseClass = Class || Ellipse;\n        const ellipse = new EllipseClass(position, radiusX, radiusY, step, options);\n        this.insert(ellipse);\n        return ellipse;\n    }\n    /**\n     * create polygon at position with options and add to system\n     */\n    createPolygon(position, points, options, Class) {\n        const PolygonClass = Class || Polygon;\n        const polygon = new PolygonClass(position, points, options);\n        this.insert(polygon);\n        return polygon;\n    }\n    /**\n     * re-insert body into collision tree and update its bbox\n     * every body can be part of only one system\n     */\n    insert(body) {\n        body.bbox = body.getAABBAsBBox();\n        if (body.system) {\n            // allow end if body inserted and not moved\n            if (!bodyMoved(body)) {\n                return this;\n            }\n            // old bounding box *needs* to be removed\n            body.system.remove(body);\n        }\n        // only then we update min, max\n        body.minX = body.bbox.minX - body.padding;\n        body.minY = body.bbox.minY - body.padding;\n        body.maxX = body.bbox.maxX + body.padding;\n        body.maxY = body.bbox.maxY + body.padding;\n        // reinsert bounding box to collision tree\n        return super.insert(body);\n    }\n    /**\n     * updates body in collision tree\n     */\n    updateBody(body) {\n        body.updateBody();\n    }\n    /**\n     * update all bodies aabb\n     */\n    update() {\n        forEach(this.all(), (body) => {\n            this.updateBody(body);\n        });\n    }\n    /**\n     * draw exact bodies colliders outline\n     */\n    draw(context) {\n        forEach(this.all(), (body) => {\n            body.draw(context);\n        });\n    }\n    /**\n     * draw bounding boxes hierarchy outline\n     */\n    drawBVH(context, isTrigger = true) {\n        const drawChildren = (body) => {\n            drawBVH(context, body, isTrigger);\n            if (body.children) {\n                forEach(body.children, drawChildren);\n            }\n        };\n        forEach(this.data.children, drawChildren);\n    }\n    /**\n     * remove body aabb from collision tree\n     */\n    remove(body, equals) {\n        body.system = undefined;\n        return super.remove(body, equals);\n    }\n    /**\n     * get object potential colliders\n     * @deprecated because it's slower to use than checkOne() or checkAll()\n     */\n    getPotentials(body) {\n        // filter here is required as collides with self\n        return filter(this.search(body), (candidate) => candidate !== body);\n    }\n    /**\n     * used to find body deep inside data with finder function returning boolean found or not\n     *\n     * @param traverseFunction\n     * @param tree\n     */\n    traverse(traverseFunction, { children } = this.data) {\n        return children?.find((body, index) => {\n            if (!body) {\n                return false;\n            }\n            if (body.typeGroup && traverseFunction(body, children, index)) {\n                return true;\n            }\n            // if callback returns true, ends forEach\n            if (body.children) {\n                this.traverse(traverseFunction, body);\n            }\n        });\n    }\n}\n","import { BaseSystem } from \"./base-system\";\nimport { Line } from \"./bodies/line\";\nimport { ensureConvex, intersectCircleCircle, intersectLineCircle, intersectLineLine, intersectLinePolygon, } from \"./intersect\";\nimport { BodyGroup, Response, SATVector, } from \"./model\";\nimport { forEach, some } from \"./optimized\";\nimport { canInteract, checkAInB, distance, getSATTest, notIntersectAABB, returnTrue, } from \"./utils\";\n/**\n * collision system\n */\nexport class System extends BaseSystem {\n    constructor() {\n        super(...arguments);\n        /**\n         * the last collision result\n         */\n        this.response = new Response();\n    }\n    /**\n     * re-insert body into collision tree and update its bbox\n     * every body can be part of only one system\n     */\n    insert(body) {\n        const insertResult = super.insert(body);\n        // set system for later body.system.updateBody(body)\n        body.system = this;\n        return insertResult;\n    }\n    /**\n     * separate (move away) bodies\n     */\n    separate(callback = returnTrue, response = this.response) {\n        forEach(this.all(), (body) => {\n            this.separateBody(body, callback, response);\n        });\n    }\n    /**\n     * separate (move away) 1 body, with optional callback before collision\n     */\n    separateBody(body, callback = returnTrue, response = this.response) {\n        if (body.isStatic && !body.isTrigger) {\n            return;\n        }\n        const offsets = { x: 0, y: 0 };\n        const addOffsets = (collision) => {\n            // when is not trigger and callback returns true it continues\n            if (callback(collision) && !body.isTrigger && !collision.b.isTrigger) {\n                offsets.x += collision.overlapV.x;\n                offsets.y += collision.overlapV.y;\n            }\n        };\n        this.checkOne(body, addOffsets, response);\n        if (offsets.x || offsets.y) {\n            body.setPosition(body.x - offsets.x, body.y - offsets.y);\n        }\n    }\n    /**\n     * check one body collisions with callback\n     */\n    checkOne(body, callback = returnTrue, response = this.response) {\n        // no need to check static body collision\n        if (body.isStatic && !body.isTrigger) {\n            return false;\n        }\n        const bodies = this.search(body);\n        const checkCollision = (candidate) => {\n            if (candidate !== body &&\n                this.checkCollision(body, candidate, response)) {\n                return callback(response);\n            }\n        };\n        return some(bodies, checkCollision);\n    }\n    /**\n     * check all bodies collisions in area with callback\n     */\n    checkArea(area, callback = returnTrue, response = this.response) {\n        const checkOne = (body) => {\n            return this.checkOne(body, callback, response);\n        };\n        return some(this.search(area), checkOne);\n    }\n    /**\n     * check all bodies collisions with callback\n     */\n    checkAll(callback = returnTrue, response = this.response) {\n        const checkOne = (body) => {\n            return this.checkOne(body, callback, response);\n        };\n        return some(this.all(), checkOne);\n    }\n    /**\n     * check do 2 objects collide\n     */\n    checkCollision(bodyA, bodyB, response = this.response) {\n        const { bbox: bboxA, padding: paddingA } = bodyA;\n        const { bbox: bboxB, padding: paddingB } = bodyB;\n        // assess the bodies real aabb without padding\n        /* tslint:disable-next-line:cyclomatic-complexity */\n        if (!bboxA ||\n            !bboxB ||\n            !canInteract(bodyA, bodyB) ||\n            ((paddingA || paddingB) && notIntersectAABB(bboxA, bboxB))) {\n            return false;\n        }\n        const sat = getSATTest(bodyA, bodyB);\n        // 99% of cases\n        if (bodyA.isConvex && bodyB.isConvex) {\n            // always first clear response\n            response.clear();\n            return sat(bodyA, bodyB, response);\n        }\n        // more complex (non convex) cases\n        const convexBodiesA = ensureConvex(bodyA);\n        const convexBodiesB = ensureConvex(bodyB);\n        let overlapX = 0;\n        let overlapY = 0;\n        let collided = false;\n        forEach(convexBodiesA, (convexBodyA) => {\n            forEach(convexBodiesB, (convexBodyB) => {\n                // always first clear response\n                response.clear();\n                if (sat(convexBodyA, convexBodyB, response)) {\n                    collided = true;\n                    overlapX += response.overlapV.x;\n                    overlapY += response.overlapV.y;\n                }\n            });\n        });\n        if (collided) {\n            const vector = new SATVector(overlapX, overlapY);\n            response.a = bodyA;\n            response.b = bodyB;\n            response.overlapV.x = overlapX;\n            response.overlapV.y = overlapY;\n            response.overlapN = vector.normalize();\n            response.overlap = vector.len();\n            response.aInB = checkAInB(bodyA, bodyB);\n            response.bInA = checkAInB(bodyB, bodyA);\n        }\n        return collided;\n    }\n    /**\n     * raycast to get collider of ray from start to end\n     */\n    raycast(start, end, allow = returnTrue) {\n        let minDistance = Infinity;\n        let result;\n        if (!this.ray) {\n            this.ray = new Line(start, end, { isTrigger: true });\n        }\n        else {\n            this.ray.start = start;\n            this.ray.end = end;\n        }\n        this.insert(this.ray);\n        this.checkOne(this.ray, ({ b: body }) => {\n            if (!allow(body, this.ray)) {\n                return false;\n            }\n            const points = body.typeGroup === BodyGroup.Circle\n                ? intersectLineCircle(this.ray, body)\n                : intersectLinePolygon(this.ray, body);\n            forEach(points, (point) => {\n                const pointDistance = distance(start, point);\n                if (pointDistance < minDistance) {\n                    minDistance = pointDistance;\n                    result = { point, body };\n                }\n            });\n        });\n        this.remove(this.ray);\n        return result;\n    }\n    /**\n     * find collisions points between 2 bodies\n     */\n    getCollisionPoints(a, b) {\n        const collisionPoints = [];\n        if (a.typeGroup === BodyGroup.Circle && b.typeGroup === BodyGroup.Circle) {\n            collisionPoints.push(...intersectCircleCircle(a, b));\n        }\n        if (a.typeGroup === BodyGroup.Circle && b.typeGroup !== BodyGroup.Circle) {\n            for (let indexB = 0; indexB < b.calcPoints.length; indexB++) {\n                const lineB = b.getEdge(indexB);\n                collisionPoints.push(...intersectLineCircle(lineB, a));\n            }\n        }\n        if (a.typeGroup !== BodyGroup.Circle) {\n            for (let indexA = 0; indexA < a.calcPoints.length; indexA++) {\n                const lineA = a.getEdge(indexA);\n                if (b.typeGroup === BodyGroup.Circle) {\n                    collisionPoints.push(...intersectLineCircle(lineA, b));\n                }\n                else {\n                    for (let indexB = 0; indexB < b.calcPoints.length; indexB++) {\n                        const lineB = b.getEdge(indexB);\n                        const hit = intersectLineLine(lineA, lineB);\n                        if (hit) {\n                            collisionPoints.push(hit);\n                        }\n                    }\n                }\n            }\n        }\n        // unique\n        return collisionPoints.filter(({ x, y }, index) => index ===\n            collisionPoints.findIndex((collisionPoint) => collisionPoint.x === x && collisionPoint.y === y));\n    }\n}\n"],"names":["this","pointInCircle","pointInConvexPolygon","testCircleCircle","testCirclePolygon","testPolygonCircle","testPolygonPolygon","SATVector","Response","SATCircle","SATPolygon"],"mappings":"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","x_google_ignoreList":[0,3]}